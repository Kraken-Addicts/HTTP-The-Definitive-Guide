## 07장 :octopus: 캐시

### 7.1 　  불필요한 데이터 전송　 `junslee`
1. 캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다. (O / X)
1. 캐시를 이용하면, 첫번째 서버 응답은 캐시에 보관된다. (O / X)
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다. (O)
1. 캐시를 이용하면, 첫번째 서버 응답은 캐시에 보관된다. (O)

</div>
</details>
<br>

### 7.2_ 　  대역폭 병목　 `junslee`
1. 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 `(넓은 / 좁은)` 대역폭을 제공하기 때문에 `____`을 이용하면 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있다.
2. 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 빠른 네트워크의 속도와 같다. (O / X) 
3. 클라이언트가 `(LAN(근거리통신망) / WAN(광역통신망))`에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있다.
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 '넓은' 대역폭을 제공하기 때문에 '캐싱'을 이용하면 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있다.
2. 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 빠른 네트워크의 속도와 같다. (X) <br>
  -> 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 '느린' 네트워크의 속도와 같다.
3. 클라이언트가 빠른 'LAN(근거리 통신망)'에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있다.

</div>
</details>
<br>

### 7.3 　  갑작스런 요청 쇄도(Flash Crowds)　 `junslee`
1. 네트워크에 접속은 고르게 있을 때도 많지만, 갑작스런 사건으로 인해 트래픽이 급증하여 심각한 장애를 야기시키는데, 캐싱은 이러한 상황에 대처하기 위해 특히 중요하다. (O / X)
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 네트워크에 접속은 고르게 있을 때도 많지만, 갑작스런 사건으로 인해 트래픽이 급증하여 심각한 장애를 야기시키기도 하는데, 캐싱은 이러한 상황에 대처하기 위해 특히 중요하다. (O)

</div>
</details>
<br>

### 7.4 　  거리로 인한 지연　 `junslee`
1. 페이지를 먼 곳에서 불러오면 시간이 많이 걸리는데, 캐시는 `____`로 인한 지연을 줄여준다.
2. 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다. (O / X)
3. 인터넷 트래픽을 지연시키는 요소는 클라이언트와 서버 사이에 존재하는 라우터 뿐이다. (O / X)
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 페이지를 먼 곳에서 불러오면 시간이 많이 걸리는데, 캐시는 `거리`로 인한 지연을 줄여준다.
2. 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다. (O)
3. 인터넷 트래픽을 지연시키는 요소는 클라이언트와 서버 사이에 존재하는 라우터 뿐이다. (X) <br>
 -> 클라이언트와 서버 사이에 라우터가 그다지 많지 않더라고, 빛의 속도 그 자체가 유의미한 지연을 유발한다.
`보스턴과 샌프란시스코 사이의 거리는 약 4,400km이다. 어떤 웹페이자가 20개의 작은 이미지를 포함하고 있는데, 모두가 샌프란시스코에 있는 한 서버에 들어있다고 가정해보자.
보스턴에 있는 클라가 서버로 동시에 4개의 커넥션을 열고, 그 커넥션을 유지한다면, 다운 받을 때의 빛의 속도로 인한 지연은 거의 1/4초가 된다.(240밀리초) 만약 서버가 보스턴에서 더 멀리 10,800km 떨어진 도쿄라면 600밀리초로 커진다.`
</div>
</details>
<br>

### 7.5 　  적중과 부적중　 `mihykim`
- 보기 중 알맞은 단어를 골라 빈 칸을 채워주세요
    - `<보기> 캐시 부적중(cache miss), 캐시적중(cache hit), 바이트 적중률, 캐시 적중률`
    - 캐시에 요청이 도착했을 때, 대응하는 사본이 있는 경우를 `______________________`이라고 한다
    - 반대로 대응하는 사본이 없는 경우를 `______________________`이라고 부른다.
    - `______________________`은 캐시가 요청을 처리하는 비율을 뜻한다. 이 값이 40%이면 웹 캐시로 괜찮은 편이다.
    - `______________________`은 용량이 큰 객체는 몇 번 덜 접근되어도 전체 트래픽에 더 크게 기여하는 것까지 반영한 지표다.
- 빈 칸을 알맞은 문구로 채워주세요  _(주관식, 5자 이내)_
    - 원 서버 콘텐츠는 변경될 수 있기 때문에 캐시는 스스로 원한다면 언제든지 사본을 재검사할 수 있다. 그러나 캐시가 문서를 수백만 개씩 갖고있는 경우가 흔한데 비해, 네트워크 대역폭은 부족하기 때문에 `____________` 가 사본을 요청하였으며, 그 사본이 검사를 할 필요가 있을 정도로 충분히 `_________` 경우에만 재검사를 한다.
 - 괄호 안의 두 개의 보기 중 적절한 항목을 선택해주세요
     - 캐시는 객체를 재검사하기 위해 ( GET / OPTIONS ) 요청에 ( If-Modified-Since / Since-Modified-If ) 헤더를 추가하여 서버에게 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라고 요청할 수 있다.
 - 보기는 위 요청에 대하여 서버가 보낼 수 있는 응답메세지의 3가지 상태코드입니다. 각 상황에 알맞는 상태코드를 골라 짝지어주세요
     - `<보기> 200 OK, 304 Not Modified, 404 Not Found`
     - 재검사 적중(서버 컨텐츠가 그대로인 경우) : `_________________`
     - 재검사 부적중(서버 컨텐츠가 변경된 경우) : `_________________`
     - 객체 삭제(서버 컨텐츠가 삭제된 경우) : `_________________`
- 아래는 주관식 문제입니다. 
    - 만약 서버로부터 객체가 삭제되었다는 응답코드를 받았을 경우 캐시가 해야할 일은? `________________`
    - 캐시 적중이었다면 클라이언트가 받는 응답코드는?  `________________`
    - 캐시 부적중으로 원 서버에 접근한다면 클라이언트가 받는 응답코드는? `________________`

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 보기 중 알맞은 단어를 골라 빈 칸을 채워주세요
    - 캐시에 요청이 도착했을 때, 대응하는 사본이 있는 경우를 `캐시 적중(cache hit)`이라고 한다
    - 반대로 대응하는 사본이 없는 경우를 `캐시 부적중(cache miss)`이라고 부른다.
    - `캐시 적중률`은 캐시가 요청을 처리하는 비율을 뜻한다. 이 값이 40%이면 웹 캐시로 괜찮은 편이다.
    - `바이트 적중률`은 용량이 큰 객체는 몇 번 덜 접근되어도 전체 트래픽에 더 크게 기여하는 것까지 반영한 지표다.
- 빈 칸을 알맞은 문구로 채워주세요  _(주관식, 5자 이내)_
    - 원 서버 콘텐츠는 변경될 수 있기 때문에 캐시는 스스로 원한다면 언제든지 사본을 재검사할 수 있다. 그러나 캐시가 문서를 수백만 개씩 갖고있는 경우가 흔한데 비해, 네트워크 대역폭은 부족하기 때문에 `클라이언트` 가 사본을 요청하였으며, 그 사본이 검사를 할 필요가 있을 정도로 충분히 `오래된` 경우에만 재검사를 한다.
 - 괄호 안의 두 개의 보기 중 적절한 항목을 선택해주세요
     - 캐시는 객체를 재검사하기 위해 `GET` 요청에 `( If-Modified-Since)`헤더를 추가하여 서버에게 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라고 요청할 수 있다. _(각 택1)_
 - 보기는 위 요청에 대하여 서버가 보낼 수 있는 응답메세지의 3가지 상태코드입니다. 각 상황에 알맞는 상태코드를 골라 짝지어주세요
     - <보기> `200 OK` `304 Not Modified` `404 Not Found`
     - 재검사 적중(서버 컨텐츠가 그대로인 경우) : `304 Not Modified`
     - 재검사 부적중(서버 컨텐츠가 변경된 경우) : `200 OK`
     - 객체 삭제(서버 컨텐츠가 삭제된 경우) : `404 Not Found`
- 아래는 주관식 문제입니다. 
    - 만약 서버로부터 객체가 삭제되었다는 응답코드를 받았을 경우 캐시가 해야할 일은? `사본을 삭제한다`
    - 캐시 적중이었다면 클라이언트가 받는 응답코드는?  `200 OK`
    - 캐시 부적중으로 원 서버에 접근한다면 클라이언트가 받는 응답코드는? `200 OK`
        - 두 경우 모두 응답 코드는 응답이 본문을 갖고있음을 의미하는 `200 OK`이다.
        - 클라이언트가 적중과 부적중을 구별하는 한 가지 방법은 Date헤더를 이용하는 것이다. 응답의 Date 헤더 값이 현재 시각보다 오래되었다면 응답은 캐시된 것이다. 또다른 방법은 Age헤더를 이용하는 것이다.

</div>
</details>
<br>

### 7.6 　  캐시 토폴로지　 `daelee`
- 토폴로지(topology): 연결방식, 망구성방식
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 7.7 　  캐시 처리 단계　 `daelee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 7.8 　  사본을 신선하게 유지하기　 `secho`

- 1. 온라인 신문처럼 매일 바뀌는 문서들을 위해 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야한다. (O / X)
- 2. HTTP는 `cache-control`과 `Expires`라는 특별한 헤더로 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다. 다음에 빈칸을 채우세요.

```
HTTP/1.0 200 OK
Date: Mon, 10 Aug 2020, 13:00 GMT
Content-type : text/plain
Content-length : 67
(빈칸) : Fri, 15 Aug 2020, 05:00 GMT
...
```

```
HTTP/1.0 200 OK
Date: Mon, 10 Aug 2020, 13:00 GMT
Content-type : text/plain
Content-length : 67
(빈칸) : max-age = 484200
...
```



- 3. 캐시된 문서가 만료되면 캐시는 서버와 문서에 변경된 것이 있는지 검사하고 그렇다면 `신선한 사본`을 `새 유효기간`과 함께 얻어온다. (O / X)
- 4. 캐시된 문서가 만료되었으면 해당 문서는 원서버의 문서와 다르므로 원서버에 문서를 요청해 갱신해야한다.  ( O / X )
- 5. 캐시된 문서가 만료되었을 때 재검사를 수행해야한다. 재검사 결과 콘텐츠가 변경되지 않았으면 캐시는 새로운 사본과 새 만료일을 포함한 새 헤더들을 가져와서 갱신해야한다 (O / X )



- 6. 다음은 HTTP 응답헤더의 일부이다. `ETag`를 제공할 수 있는 조건부 요청헤더는? (주관식)
  - 조건부 메서드는 재검사를 효율적으로 만들어주며 요청에 특별한 조건부 헤더를 추가함으로써 조건이 참인 경우에만 웹 서버는 객체를 반환한다.

```
200 OK
Access-Control-Allow-Origin: *
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Mon, 18 Jul 2016 16:06:00 GMT
Etag: "c561c68d0ba92bbeb8b0f612a9199f722e3a621a"
https://gmlwjd9405.github.io/2019/01/28/http-header-types.html
```



- 7. 다음은 조건부 요청과 응답에 대한 내용이다. 문서가 변경되었는지에 대한 여부를 판단하고, 그에 대한 이유를 작성하시오

```
조건부 요청
GET /announce.html HTTP/1.0
If-Modified-Since: Mon, 10 Aug 2020, 14:30:00
```

```
응답
HTTP/1.0 200 OK
Date: Fri, 05 Sep 2020, 18:33:33
Content-type: text/plain
Content-length: 100
Expires: Mon, 09 Sep 2020, 05:00:00

I am a seasoned wedding planner.
It occured to me that I hardly get any updates on your work progress these days
```



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


- 온라인 신문처럼 매일 바뀌는 문서들을 위해 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야한다. (O / X) - ( O )
- HTTP는 `cache-control`과 `Expires`라는 특별한 헤더로 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다. 다음에 빈칸을 채우세요.

```
HTTP/1.0 200 OK
Date: Mon, 10 Aug 2020, 13:00 GMT
Content-type : text/plain
Content-length : 67
(빈칸) : Fri, 15 Aug 2020, 05:00 GMT
...
```

```
HTTP/1.0 200 OK
Date: Mon, 10 Aug 2020, 13:00 GMT
Content-type : text/plain
Content-length : 67
(빈칸) : max-age = 484200
...
```

(Expires, Cache-Control) = 둘이 같은 일을 하지만, expires은 절대 유효기간을 cache-control은 초단위로 명시한다.

cache-control은 처음 생성된 이후부터 명시된 시간까지 신선함을 의미함.

- 캐시된 문서가 만료되면 캐시는 서버와 문서에 변경된 것이 있는지 검사하고 그렇다면 `신선한 사본`을 `새 유효기간`과 함께 얻어온다. (O / X) - ( O )
- 캐시된 문서가 만료되었으면 해당 문서는 원서버의 문서와 다르므로 원서버에 문서를 요청해 갱신해야한다.  ( O / X ) = ( X ) 캐시만료는 해당 문서와 서버의 문서가 다르다는 것을 의미하지 않음. 검사할 시간이 되었다는 의미.
- 캐시된 문서가 만료되었을 때 재검사를 수행해야한다. 재검사 결과 콘텐츠가 변경되지 않았으면 캐시는 새로운 사본과 새 만료일을 포함한 새 헤더들을 가져와서 갱신해야한다 (O / X ) = X 콘텐츠변경이 없었으면 헤더들만 가져와서 갱신하면 됨.



- 다음은 HTTP 응답헤더의 일부이다. `ETag`를 제공할 수 있는 조건부 요청헤더는? (주관식) => `If-None-Match`. 문서에 대한 일련번호와 같이 동작하는 특별태그 (ETag)를 제공할 수 있음. Http컨텐츠가 바뀌었는지 검사할 수 있는 태그



- 다음은 조건부 요청과 응답에 대한 내용이다. 문서가 변경되었는지에 대한 여부를 판단하고, 그에 대한 이유를 작성하시오
  - 변경이 없는 경우 304를 반환하고 변경시 **본문**과 함께 200을 반환함.

</div>
</details>
<br>

### 7.9 　  캐시 제어　 `jehong`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 7.10 　 캐시 제어 설정　 `taelee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 7.11 　 자세한 알고리즘　 `yeosong`
#### 7.11.1 나이와 신선도 수명
1. 신선도 수명의 계산은 클라이언트에 따라 달라지는 것이 아니며, 서버에 설정된 알고리즘에 따라 동일하게 계산됨을 규칙으로 한다. (O/X)
 
#### 7.11.2 나이 계산
2. 응답의 나이는 서버에서 생성 혹은 재검사 되었을 때부터 지금까지의 총 시간으로, 게이트웨이에 머무른 시간을 제외한 값으로 이루어져있다.(O/X)
  
3. 겉보기 나이는 `_____`에 기반한다. 겉보기 나이 = (응답을 받은 시각 -  `_____` 값) 인데, 이는 객체가 원서버에서 최초로 생겨난 일시를 표현한 것이다.

4. 두 컴퓨터의 시계 설정 차이로 인한 문제를 `_________` 라고 하며, 이로 인해 음수 값이 나올 경우 바로 `__`으로 수정한다.
  
5. 현재, 클록 스큐로 인한 정확도 손실을 보정하는 완전한 보정법은 없다. (O/X)

6. 다음 보기 중 옳은 것을 골라 빈 칸을 채우세요. (      )

a. `$응답을_받은_시각 - $요청을_보낸_시각`
b. `$Date_헤더값 - $응답을_받은_시각`
c. `$보정된_겉보기_나이 + $응답_지연_추정값`
d. `$응답을_받은_시각 - $Date_헤더값`
e. `$겉보기_나이, $Age_헤더값`

~~~
$겉보기_나이 = max(0, ____________);
$보정된_겉보기_나이 = max(______________);
$응답_지연_추정값 = (_________________);
$문서가_우리의_캐시에_도착했을_때의_나이 = ___________________
~~~

#### 7.11.3 완전한 나이 계산 알고리즘

7. 앞서 계산한 $문서가_우리의_캐시에_도착했을_때의_나이에 무엇을 더해야 완전한 나이 계산 알고리즘이 되는가? (주관식)

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
#### 7.11.1 나이와 신선도 수명
1. 신선도 수명의 계산은 클라이언트에 따라 달라지는 것이 아니며, 서버에 설정된 알고리즘에 따라 동일하게 계산됨을 규칙으로 한다. (X)
  - 신선도 수명의 계산 = (서버 만료 정보 + 클라이언트의 요구 사항)의 조합에 따라 다르다.
  - max-stale 헤더를 다음과 같이 사용하면 `Cache-Control: max-stale=600` 만료된 컨텐츠라도 만료 후 10분이 지나기 전이라면 재사용 할 수 있다.
  - min-fresh 헤더를 다음과 같이 사용하면 `Cache-Control: min-fresh=60` 지금부터 1분 후까지도 신선할 문서라면 받아들인다. 
 
#### 7.11.2 나이 계산
2. 응답의 나이는 서버에서 생성 혹은 재검사 되었을 때부터 지금까지의 총 시간으로, 게이트웨이에 머무른 시간을 제외한 값으로 이루어져있다.(X)
  - 중개 캐시에 기록되어있는 '라우터들과 게이트웨이들 사이를 떠돌아다닌 시간, 응답이 캐시에 머물렀던 시간'이 모두 포함되어있다.
  
3. 겉보기 나이는 `Date 헤더`에 기반한다. 겉보기 나이 = 응답을 받은 시각 - `Date 헤더` 값 인데, 이는 객체가 원서버에서 최초로 생겨난 일시를 표현한 것이다.
  - 참고) Date 헤더는 원 서버의 날짜 기록이기 때문에 프락시와 캐시에서 절대 수정되어선 안된다.

4. 두 컴퓨터의 시계 설정 차이로 인한 문제를 `클록 스큐 clock skew` 라고 하며, 이로 인해 음수 값이 나올 경우 바로 `0`으로 수정한다.
  
5. 현재, 클록 스큐로 인한 정확도 손실을 보정하는 완전한 보정법은 없다. (O) 219p [점층적 나이 계산] 참고
  - HTTP/1.1에서 우회책으로 서버간 비교, 종단간 비교를 안하고 상대적인 나이를 누적하도록 하긴 하지만, 1.1이 아닌 경우와 소통할 때는 불완전한 추정값으로 계산한다.
  
6. 다음 보기 중 옳은 것을 골라 빈 칸을 채우세요. (d, e, a, c)

a. `$응답을_받은_시각 - $요청을_보낸_시각`
b. `$Date_헤더값 - $응답을_받은_시각`
c. `$보정된_겉보기_나이 + $응답_지연_추정값`
d. `$응답을_받은_시각 - $Date_헤더값`
e. `$겉보기_나이, $Age_헤더값`

~~~
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값
~~~

#### 7.11.3 완전한 나이 계산 알고리즘

7. 앞서 계산한 $문서가_우리의_캐시에_도착했을_때의_나이에 무엇을 더해야 완전한 나이 계산 알고리즘이 되는가? (주관식)
  - $사본이_얼마나_오래_우리의_캐시에_있었는지 를 더해야 한다. 

#### 7.11.4 신선도 수명 계산
지금까지 계산한 나이가 신선도 수명보다 작을 때 우리는 이것을 '신선하다'고 판단한다.
클라이언트에 따라 원하는 신선도가 다를 수 있고 - 정기간행물이라면 다음 출판일 이전이라면 무조건 신선한 것이 되지만,
속도만 빠르다면 약간 오래된 콘텐츠를 받고 싶은 클라이언트도 있을 것이다 - 캐시는 이 조건들에 충실해야한다.

#### 7.11.5 완전한 서버 신선도 알고리즘
1. 문서의 나이 계산
2. 서버 신선도 한계를 계산
3. 클라이언트가 수정한 신선도 한계 계산
4. $최종_신선도_한계 > $문서의_나이 ? 신선 : 신선하지않음;

</div>
</details>
<br>

### 7.12 　 캐시와 광고　 `hylee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>
