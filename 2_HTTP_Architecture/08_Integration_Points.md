## 08장 :octopus: 통합점: 게이트웨이, 터널, 릴레이

### 8.1 　  게이트웨이　 `kukim`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.2 　  프로토콜 게이트웨이　 `kukim`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.3 　  리소스 게이트웨이　 `junslee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.4 　  애플리케이션 인터페이스와 웹 서비스　 `junslee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.5 　  터널　 `mihykim`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.6 　  릴레이　 `daelee`
1. 릴레이는 커넥션을 맺기 위해 HTTP 통신을 한다. (O/X)
2. 릴레이는 언제 유용하게 사용될까?

  - 동료/서비스가 public ip가 없을때, 혹은 유동ip를 사용할 때.

  - 보안/기술적인 이유로 포트를 열 수 없을때

  - 애플리케이션을 HTTP 서버로 구축할 수 없을때

  - 동료가 HTTP Proxy 서버 뒤에 있을때
3. 릴레이를 구현하는데 관련된 더 일반적인 문제 중 하나는 릴레이가 `___(a)___` 헤더를 제대로 처리하지 못해서 `___(b)___` 커넥션이 행(hang)에 걸리는 것이다.

  
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 릴레이는 커넥션을 맺기 위해 HTTP 통신을 한다.

   > HTTP 릴레이는 `HTTP 명세`를 완전히 준수하지 않는 간단한 `HTTP 프록시`다. 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 **맹목적으로 전달**한다.

   > HTTP는 복잡하기에, 모든 헤더와 메서드 로직을 **수행하지 않고** 맹목적으로 트래픽을 전달하는 `간단한 프록시`를 구현하는 방식이 유용할 때가 있다.

2. 릴레이는 언제 유용하게 사용될까?

(a) 동료/서비스가 public ip가 없을때, 혹은 유동ip를 사용할 때

(b) 보안/기술적인 이유로 포트를 열 수 없을 때

(c) 애플리케이션을 HTTP 서버로 구축할 수 없을 때

(d) 동료가 HTTP Proxy 서버 뒤에 있을 때
   

3. `단순 맹목적 릴레이`를 구현하는데 관련된 더 일반적인 문제 중 하나는 맹목적 릴레이가 `___(a)___` 헤더를 제대로 처리하지 못해서 `___(b)___` 커넥션이 행(hang)에 걸리는 것이다.

   > (a) : Connection
   >
   > (b) : Keep-Alive
   >
   > `Connection 헤더`는 홉(클라이언트)과 홉(릴레이 프록시) 사이에만 사용하는 헤더인데, 이를 이해하지 못하고 다음 홉(서버)에 넘겨 `행`이 걸리는 것이다.

4. HTTP 커넥션이 hang에 걸리는 상황

   1. `클라이언트`가 `릴레이`에게 `Keep-Alive 커넥션`을 맺고싶다는 요청을 보냄.
   2. `릴레이`는 커넥션 헤더를 처리하지 못하고 그대로 `서버` 에게 전달. 
   3. `릴레이`와 `서버`간 `Keep-Alive 커넥션`이 맺어짐.
   4. `릴레이`는 `웹서버`로부터 받은 응답을 `클라이언트`에 전달. 이 응답 헤더에는 `Connection: Keep-Alive 헤더`가 포함되어 있기 때문에(물론 릴레이는 이해하지 못하지만) `클라이언트`는 `릴레이`가 자신과 Keep-Alive로 통신하고 있다고 믿음.
   5. `릴레이`는 전달했으니 `서버`가 연결을 끊기를 기다리지만, `서버`는 끊지 않음. 계속 커넥션을 맺고(hang) 있음.
   6. `클라이언트`가 바로 다음 요청을 `릴레이`에게 전송하지만, 같은 커넥션으로 또 다른 요청이 오는 것을 예측하지 못하는 `릴레이`는 요청을 처리하지 못함. 
   7. 아무런 작업도 진행되지 않는 hang 상태 지속

</div>
</details>
<br>
