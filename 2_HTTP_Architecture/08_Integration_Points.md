## 08장 :octopus: 통합점: 게이트웨이, 터널, 릴레이

### 8.1 　  게이트웨이　 `kukim`

1. 그림을 참고하여 아래에 답하시오.  
![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcTShD1%2FbtqDQ8zqmH5%2F1Z8hrRNKAg9BcMS5ydmhN1%2Fimg.jpg)

1.1. a) 클라이언트가 게이트웨이를 통해 웹서버에 FTP 요청하는 순서는 무엇인가?
- 1. FTP 커넥션을 맺는다.
- 2. FTP 서버에 적절한 명령을 전송한다.
- 3. 적절한 HTTP 헤더와 함께 HTTP를 클라이언트에게 보낸다.
- 4. FTP URL을 가르키는 HTTP 요청을 받는다.

1.2. b) HTTPS/HTTP의 상황에서 게이트웨이는 해당 서버 인증서를 설치할 필요 없이 클라이언트가 보낸 암호화 정보를 서버에게 인증을 요청해 암호를 해독한 후 서버에게 보내준다. (O/X)

1.3 c)클라이언트가 웹에서 물건을 사거나 일기예보를 보거나 주식정보를 볼 때 사실 웹 서버에 직접 방문하여 항상 정적인 정보를 요청하여 확인한다. (O/X) 

2. 다음 중 클라이언트 프로토콜과 서버 프로토콜은 무엇인가?
- `HTTP/FTP`일 때
  - 클라이언트 프로토콜 : `_____`
  - 서버 프로토콜 : `_____`
 
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
1.1.  
 - 4 -> 1-> 2-> 3

1.2.  
정답 : X  (게이트웨이가 인증서를 서버의 인증서를 가지고 있어 SSL 암호화를 해독한 후 서버에게 보내준다.)

1.3.  
정답 : X (웹서버에 직접 http 요청하여 정적인 자료를 받을 수 있지만 서버마다 그 구조가 다르고 정적인 콘텐츠, 동적인 콘텐츠, 애플리케이션 서버 게이트웨이를 통해 얻는 등 많은 방법이 있다.)

2.  
클라리언트 프로토콜 : `HTTP`  
서버 프로토콜 : `FTP`  
</div>
</details>
<br>

### 8.2 　  프로토콜 게이트웨이　 `kukim`
1. 클라이언트가 서버에 HTTP를 활용해 FTP 요청을 할때 게이트웨이에 HTTP 트래픽을 바로 보낼수 없다. (O/X) 
2. HTTP/HTTPS 와 HTTPS/HTTP의 차이를 설명하시오. (주관식)


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
1.   
정답 : X (프락시에 트래픽을 바로 보내는 것 같이 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있다.(브라우저에서 명시적으로 설정도 가능하다.))  

2.  
HTTP/HTTPS는 클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만 게이트웨이는 자동으로 사용자의 모든 정보를 암호화하여 서버에게 전송하는 시스템이고 HTTPS/HTTP는 클라이언트에게 HTTPS 요청을 받아 복호화하여 웹서버로 HTTP 요청을 보낸다. 게이트웨이와 원 서버 간의 암호화하지 않은 트래픽을 전송하기 때문에 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 하고 사용해야 한다.    
<a href="https://ibb.co/P410Kkr"><img src="https://i.ibb.co/5vswmZ1/Screen-Shot-2020-08-12-at-3-00-41-PM.png" alt="Screen-Shot-2020-08-12-at-3-00-41-PM" border="0"></a>  
<a href="https://ibb.co/GcDQhr4"><img src="https://i.ibb.co/ChyKrS3/Screen-Shot-2020-08-12-at-3-00-50-PM.png" alt="Screen-Shot-2020-08-12-at-3-00-50-PM" border="0"></a>
</div>
</details>
<br>

### 8.3 　  리소스 게이트웨이　 `junslee`

1. 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고, 서버측에 있는 애플리케이션 프로그램에 연결하는 `클라이언트 / 서버` 측 게이트웨이이다.
2. CGI는 특정 `_____`에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하여 HTTP 응답으로 회신하는데 웹서버가 사용하는 표준화된 인터페이스 집합이다.
3. CGI 애플리케이션은 서버와 분리되어 있어서 다양한 언어로 구현할 수 있고, 거의 모든 HTTP 서버가 이를 지원합니다. (O / X)
<img src="https://user-images.githubusercontent.com/13018877/53302527-48dfe180-38a2-11e9-8bf8-a79b8a3c362f.png" width="600">
4. 위 그림을 보면 CGI는 각각의 클라이언트 요청에 대하여 각각의 프로세스를 생성하는데, 이러한 방식으로 인해 생길 수 있는 문제점은 무엇인가요? (주관식)<br>
<br>
5. 위의 문제점을 보완하고자 개발된 새로운 CGI형식은 무엇인가요?
<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고, 서버측에 있는 애플리케이션 프로그램에 연결하는 `서버`측 게이트웨이이다.
2. CGI는 특정 `URL`에 대한 HTTP 요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하여 HTTP 응답으로 회신하는데 웹서버가 사용하는 표준화된 인터페이스 집합이다.
3. CGI 애플리케이션은 서버와 분리되어 있어서 다양한 언어로 구현할 수 있고, 단순하므로 거의 모든 HTTP 서버가 이를 지원합니다. (O)
4. CGI는 각각의 요청에 대하여 독립적인 별도의 프로세스를 생성한다.(5개의 웹 브라우저가 똑같은 URL을 통하여 동일한 CGI를 요구하면 요청한 개수만큼 동일한 프로세스 5개를 생성한다.)
이러한 방식은 프로세스를 만드는 데 따르는 부하가 꽤 크고, 서버의 성능을 제한하며 서버 장비에 부담을 준다.
5. Fast CGI, Fast CGI는 요청이 있을 때마다 프로세스가 만들어지는 것이 아니라 만들어진 프로세스가 계속해서 새로운 요청들을 처리한다. 덕분에 프로세스를 생성하고 제거하는 데에 드는 부하가 줄어든다.

</div>
</details>
<br>

### 8.4 　  애플리케이션 인터페이스와 웹 서비스　 `junslee`

`<보기> SOAP, REST, JSON, XML`

1. 웹 서비스는 `_____`방식을 통해 `_____`데이터 포맷 을 사용하여 정보를 교환한다. 현대 웹 서비스의 데이터 교환 방식은 `_____`방식을 더 많이 쓰며, 데이터의 포맷도 `_____`을 주로 사용한다.

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 웹 서비스는 `SOAP`방식을 통해 `XML`데이터 포맷 을 사용하여 정보를 교환한다. 현대 웹 서비스의 데이터 교환 방식은 `REST`방식을 더 많이 쓰며, 데이터의 포맷도 `JSON`을 주로 사용한다. <br>
-- 참고하면 좋은 글 https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html (REST란? REST API란? RESTful이란?)

</div>
</details>
<br>

### 8.5 　  터널　 `mihykim`
- __보기에서 알맞은 단어를 골라 빈 칸을 채워주세요__
  - __\<보기\>__ <br> `패킷`, `행(hang)`, `OPTIONS`, `CONNECTION`, `CONNECT`, `HTTP`, `SSL`, `200 OK`, `200 Connection Established`, `프락시 인증`, `트랜스 코딩`, `원서버`, `게이트웨이`, `클라이언트`, `방화벽`
  - `______________`을 통해서 암호화된 `______________` 트래픽을 전달하려고 개발된 웹 터널은, HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있게 해준다.
  - 웹 터널은 `______________` 메서드를 사용하여 커넥션을 맺는다. 서버가 이 메서드를 포함한 요청을 받았고 성공했다면 `______________`라는 응답코드 및 사유구절을 반환한다.
  - 터널이 생기는 위치는 `______________`와 `______________` 사이다. 
  - 터널의 양 끝단에서는 두 커넥션으로부터 언제든지 `______________`을 받을 수 있는 준비를 해야하고, 그 데이터를 즉시 전달해야 한다. 
  - HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있다. 특히 `______________`기능은 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있다.
- __다음은 SSL커넥션을 나타낸 것입니다. 빈 칸에 들어갈 알맞은 말을 작성해주세요__ <p><img src="https://user-images.githubusercontent.com/60066472/90028238-61d98e00-dcf4-11ea-83a1-3c55de80492b.png" width="600"></p>
  - (1) `_________커넥션`
  - (2) `_________커넥션`
  - (3) `_________포트`
- __(주관식)__ 짖궂은 회사 직원 현준은 회사 방화벽에 터널을 생성하여 유해한 트래픽을 사내로 유입시키려고 한다. 이러한 터널의 오용을 최소화하기 위해서 할 수 있는 일은?
  - 게이트웨이가 잘 알려진 특정포트(e.g. HTTPS 전용 포트인 443)만 터널링 할 수 있게 허용해야 한다.
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- __보기에서 알맞은 단어를 골라 빈 칸을 채워주세요__
  - __\<보기\>__ <br> `패킷`, `행(hang)`, `OPTIONS`, `CONNECTION`, `CONNECT`, `HTTP`, `SSL`, `200 OK`, `200 Connection Established`, `프락시 인증`, `트랜스 코딩`, `원서버`, `게이트웨이`, `클라이언트`, `방화벽`
  - `방화벽`을 통해서 암호화된 `SSL` 트래픽을 전달하려고 개발된 웹 터널은, HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있게 해준다.
  - 웹 터널은 `Connect` 메서드를 사용하여 커넥션을 맺는다. 서버가 이 메서드를 포함한 요청을 받았고 성공했다면 `200 Connection Established`라는 응답코드 및 사유구절을 반환한다.
  - 터널이 생기는 위치는 `클라이언트`와 `게이트웨이` 사이다. 
  - 터널의 양 끝단에서는 두 커넥션으로부터 언제든지 `패킷`을 받을 수 있는 준비를 해야하고, 그 데이터를 즉시 전달해야 한다. 
  - HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있다. 특히 `프락시 인증`기능은 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있다.
- __다음은 SSL커넥션을 나타낸 것입니다. 빈 칸에 들어갈 알맞은 말을 작성해주세요__
  - (1) `HTTP 커넥션`
  - (2) `SSL 커넥션`
  - (3) `443 포트`
  <p><img src="https://user-images.githubusercontent.com/60066472/90028286-73229a80-dcf4-11ea-9299-446a540f1831.png" width="600"></p>
- __(주관식)__ 짖궂은 회사 직원 현준은 회사 방화벽에 터널을 생성하여 유해한 트래픽을 사내로 유입시키려고 한다. 이러한 터널의 오용을 최소화하기 위해서 할 수 있는 일은?
  - 맞춘 사람 천재

</div>
</details>
<br>

### 8.6 　  릴레이　 `daelee`
1. 릴레이는 커넥션을 맺기 위해 HTTP 통신을 한다. (O/X)
2. 릴레이는 언제 유용하게 사용될까?

  - 동료/서비스가 public ip가 없을때, 혹은 유동ip를 사용할 때.

  - 보안/기술적인 이유로 포트를 열 수 없을때

  - 애플리케이션을 HTTP 서버로 구축할 수 없을때

  - 동료가 HTTP Proxy 서버 뒤에 있을때
3. 릴레이를 구현하는데 관련된 더 일반적인 문제 중 하나는 릴레이가 `___(a)___` 헤더를 제대로 처리하지 못해서 `___(b)___` 커넥션이 행(hang)에 걸리는 것이다.

  
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 릴레이는 커넥션을 맺기 위해 HTTP 통신을 한다.

   > HTTP 릴레이는 `HTTP 명세`를 완전히 준수하지 않는 간단한 `HTTP 프록시`다. 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 **맹목적으로 전달**한다.

   > HTTP는 복잡하기에, 모든 헤더와 메서드 로직을 **수행하지 않고** 맹목적으로 트래픽을 전달하는 `간단한 프록시`를 구현하는 방식이 유용할 때가 있다.

2. 릴레이는 언제 유용하게 사용될까?

(a) 동료/서비스가 public ip가 없을때, 혹은 유동ip를 사용할 때

(b) 보안/기술적인 이유로 포트를 열 수 없을 때

(c) 애플리케이션을 HTTP 서버로 구축할 수 없을 때

(d) 동료가 HTTP Proxy 서버 뒤에 있을 때
   

3. `단순 맹목적 릴레이`를 구현하는데 관련된 더 일반적인 문제 중 하나는 맹목적 릴레이가 `___(a)___` 헤더를 제대로 처리하지 못해서 `___(b)___` 커넥션이 행(hang)에 걸리는 것이다.

   > (a) : Connection
   >
   > (b) : Keep-Alive
   >
   > `Connection 헤더`는 홉(클라이언트)과 홉(릴레이 프록시) 사이에만 사용하는 헤더인데, 이를 이해하지 못하고 다음 홉(서버)에 넘겨 `행`이 걸리는 것이다.

4. HTTP 커넥션이 hang에 걸리는 상황

   1. `클라이언트`가 `릴레이`에게 `Keep-Alive 커넥션`을 맺고싶다는 요청을 보냄.
   2. `릴레이`는 커넥션 헤더를 처리하지 못하고 그대로 `서버` 에게 전달. 
   3. `릴레이`와 `서버`간 `Keep-Alive 커넥션`이 맺어짐.
   4. `릴레이`는 `웹서버`로부터 받은 응답을 `클라이언트`에 전달. 이 응답 헤더에는 `Connection: Keep-Alive 헤더`가 포함되어 있기 때문에(물론 릴레이는 이해하지 못하지만) `클라이언트`는 `릴레이`가 자신과 Keep-Alive로 통신하고 있다고 믿음.
   5. `릴레이`는 전달했으니 `서버`가 연결을 끊기를 기다리지만, `서버`는 끊지 않음. 계속 커넥션을 맺고(hang) 있음.
   6. `클라이언트`가 바로 다음 요청을 `릴레이`에게 전송하지만, 같은 커넥션으로 또 다른 요청이 오는 것을 예측하지 못하는 `릴레이`는 요청을 처리하지 못함. 
   7. 아무런 작업도 진행되지 않는 hang 상태 지속

</div>
</details>
<br>
