## 08장 :octopus: 통합점: 게이트웨이, 터널, 릴레이

### 8.1 　  게이트웨이　 `kukim`

1. 그림을 참고하여 아래에 답하시오.
![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcTShD1%2FbtqDQ8zqmH5%2F1Z8hrRNKAg9BcMS5ydmhN1%2Fimg.jpg)

1.1. a) 클라이언트가 게이트웨이를 통해 웹서버에 FTP 요청하는 순서는 무엇인가?
- 1. FTP 커넥션을 맺는다.
- 2. FTP 서버에 적절한 명령을 전송한다.
- 3. 적절한 HTTP 헤더와 함께 HTTP를 클라이언트에게 보낸다.
- 4. FTP URL을 가르키는 HTTP 요청을 받는다.

1.2. b) HTTPS/HTTP의 상황에서 게이트웨이는 해당 서버 인증서를 설치할 필요 없이 클라이언트가 보낸 암호화 정보를 서버에게 인증을 요청해 암호를 해독한 후 서버에게 보내준다. (O/X)

1.3 c)클라이언트가 웹에서 물건을 사거나 일기예보를 보거나 주식정보를 볼 때 사실 웹 서버에 직접 방문하여 항상 정적인 정보를 요청하여 확인한다. (O/X) 

2. 다음 중 클라이언트 프로토콜과 서버 프로토콜은 무엇인가?
- `HTTP/FTP`일 때
  - 클라이언트 프로토콜 : `_____`
  - 서버 프로토콜 : `_____`
 
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
1.1.  
 - 4 -> 1-> 2-> 3

1.2.  
정답 : X  (게이트웨이가 인증서를 서버의 인증서를 가지고 있어 SSL 암호화를 해독한 후 서버에게 보내준다.)

1.3.  
정답 : X (웹서버에 직접 http 요청하여 정적인 자료를 받을 수 있지만 서버마다 그 구조가 다르고 정적인 콘텐츠, 동적인 콘텐츠, 애플리케이션 서버 게이트웨이를 통해 얻는 등 많은 방법이 있다.)

2.  
클라리언트 프로토콜 : `HTTP`  
서버 프로토콜 : `FTP`  
</div>
</details>
<br>

### 8.2 　  프로토콜 게이트웨이　 `kukim`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.3 　  리소스 게이트웨이　 `junslee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.4 　  애플리케이션 인터페이스와 웹 서비스　 `junslee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.5 　  터널　 `mihykim`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 8.6 　  릴레이　 `daelee`
1. 릴레이는 커넥션을 맺기 위해 HTTP 통신을 한다. (O/X)
2. 릴레이는 언제 유용하게 사용될까?

  - 동료/서비스가 public ip가 없을때, 혹은 유동ip를 사용할 때.

  - 보안/기술적인 이유로 포트를 열 수 없을때

  - 애플리케이션을 HTTP 서버로 구축할 수 없을때

  - 동료가 HTTP Proxy 서버 뒤에 있을때
3. 릴레이를 구현하는데 관련된 더 일반적인 문제 중 하나는 릴레이가 `___(a)___` 헤더를 제대로 처리하지 못해서 `___(b)___` 커넥션이 행(hang)에 걸리는 것이다.

  
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 릴레이는 커넥션을 맺기 위해 HTTP 통신을 한다.

   > HTTP 릴레이는 `HTTP 명세`를 완전히 준수하지 않는 간단한 `HTTP 프록시`다. 릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 **맹목적으로 전달**한다.

   > HTTP는 복잡하기에, 모든 헤더와 메서드 로직을 **수행하지 않고** 맹목적으로 트래픽을 전달하는 `간단한 프록시`를 구현하는 방식이 유용할 때가 있다.

2. 릴레이는 언제 유용하게 사용될까?

(a) 동료/서비스가 public ip가 없을때, 혹은 유동ip를 사용할 때

(b) 보안/기술적인 이유로 포트를 열 수 없을 때

(c) 애플리케이션을 HTTP 서버로 구축할 수 없을 때

(d) 동료가 HTTP Proxy 서버 뒤에 있을 때
   

3. `단순 맹목적 릴레이`를 구현하는데 관련된 더 일반적인 문제 중 하나는 맹목적 릴레이가 `___(a)___` 헤더를 제대로 처리하지 못해서 `___(b)___` 커넥션이 행(hang)에 걸리는 것이다.

   > (a) : Connection
   >
   > (b) : Keep-Alive
   >
   > `Connection 헤더`는 홉(클라이언트)과 홉(릴레이 프록시) 사이에만 사용하는 헤더인데, 이를 이해하지 못하고 다음 홉(서버)에 넘겨 `행`이 걸리는 것이다.

4. HTTP 커넥션이 hang에 걸리는 상황

   1. `클라이언트`가 `릴레이`에게 `Keep-Alive 커넥션`을 맺고싶다는 요청을 보냄.
   2. `릴레이`는 커넥션 헤더를 처리하지 못하고 그대로 `서버` 에게 전달. 
   3. `릴레이`와 `서버`간 `Keep-Alive 커넥션`이 맺어짐.
   4. `릴레이`는 `웹서버`로부터 받은 응답을 `클라이언트`에 전달. 이 응답 헤더에는 `Connection: Keep-Alive 헤더`가 포함되어 있기 때문에(물론 릴레이는 이해하지 못하지만) `클라이언트`는 `릴레이`가 자신과 Keep-Alive로 통신하고 있다고 믿음.
   5. `릴레이`는 전달했으니 `서버`가 연결을 끊기를 기다리지만, `서버`는 끊지 않음. 계속 커넥션을 맺고(hang) 있음.
   6. `클라이언트`가 바로 다음 요청을 `릴레이`에게 전송하지만, 같은 커넥션으로 또 다른 요청이 오는 것을 예측하지 못하는 `릴레이`는 요청을 처리하지 못함. 
   7. 아무런 작업도 진행되지 않는 hang 상태 지속

</div>
</details>
<br>
