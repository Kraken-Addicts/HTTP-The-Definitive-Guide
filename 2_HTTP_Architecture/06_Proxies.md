## 06장 :octopus: 프락시

[6.1　웹 중개자](#61---웹-중개자-jehong)<br>
[6.2　왜 프락시를 사용하는가?](#62---왜-프락시를-사용하는가-jehong)<br>
[6.3　프락시는 어디에 있는가?](#63---프락시는-어디에-있는가-taelee)<br>
[6.4　클라이언트 프락시 설정](#64---클라이언트-프락시-설정-yeosong)<br>
[6.5　프락시 요청의 미묘한 특징들](#65---프락시-요청의-미묘한-특징들-hylee)<br>
[6.6　메시지의 추적](#66---메시지-추적-yeha)<br>
[6.7　프락시 인증](#67---프락시-인증-kukim)<br>
[6.8　프락시 상호운용성](#68---프락시-상호운용성-kukim)<br>

### 6.1 　  웹 중개자　 `jehong`

1. HTTP 프락시 서버는 클라이언트 서버가 아니라 웹 서버다 ( O / X )

2. 프락시는 웹 서버처럼 요청과 커넥션을 다루고 응답을 돌려줘야하며 동시에 요청을 보내고 응답을 받는 올바른 HTTP 클라이언트처럼 동작해야한다. ( O / X )

3. 프락시 서버란 하나의 클라이언트가 독점으로 사용는 구조라 개인 프락시라고도 불리우며 여러 클라이언트가 공유할 수 없다는 단점이 있다. ( O / X )

4. 개인 프락시는 가장 흔한 프락시 형태로 사용자의 컴퓨터에서 직접 실행되기도 한다. ( O / X )

5. 다음 보기 중 알맞은 것을 골라 빈칸을 채우세요. (중복가능)

   <보기> `프락시` `게이트웨이`

![](https://images.velog.io/images/jehjong/post/bb2f901c-423b-4b81-9af6-a7b55833e1d1/image.png)

   a. 6-2a의 중개 장치는 클라이언트와 서버 양쪽 모두에게 HTTP로 말하고 있으므로 HTTP `________` 다.

   b. 그림 6-2b의 중개 장치는 웹 트랜잭션을 적절한 POP 트랜잭션으로 변환하여 사용자가 이메일을 HTTP를 통해 읽을 수 있게 해주는 `________`다.



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


1. HTTP 프락시 서버는 클라이언트 서버가 아니라 웹 서버다 ( O / **X** )

   > HTTP 프락시 서버는 웹 서버이기도 하고 웹 클라이언트이기도 하다. **p.148**

2. 프락시는 웹 서버처럼 요청과 커넥션을 다루고 응답을 돌려주거나 요청을 보내고 응답을 받는 올바른 HTTP 클라이언트처럼 동작해야한다. ( **O** / X )

   > HTTP 프락시는 웹 서버이면서 동시에 클라이언트여야 한다. **p.148**

3. 프락시 서버란 하나의 클라이언트가 독점으로 사용하기 때문에 개인 프락시라고도 불리우며 여러 클라이언트가 공유할 수 없다는 단점이 있다. ( O / **X** )

   > 하나의 클라이언트만을 위한 프락시를 개인 프락시, 여러 클라이언트가 함께 사용하는 프락시는 공용 프락시라 부른다. **p.148**

4. 개인 프락시는 가장 흔한 프락시 형태로 사용자의 컴퓨터에서 직접 실행되기도 한다. ( O / **X** )

   >대부분의 프락시는 공용이며 개인 프락시는 흔하지 않다. **p.149**

5. 다음 보기 중 알맞은 것을 골라 빈칸을 채우세요. (중복가능) **p.149**

   <보기> `프락시` `게이트웨이`

![](https://images.velog.io/images/jehjong/post/049950cd-fa7f-4d06-a44e-ba6777aeffe9/image.png)

   a. 6-2a의 중개 장치는 클라이언트와 서버 양쪽 모두에게 HTTP로 말하고 있으므로 HTTP `프락시` 다.
>프락시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결한다.
     
   b. 그림 6-2b의 중개 장치는 웹 트랜잭션을 적절한 POP 트랜잭션으로 변환하여 사용자가 이메일을 HTTP를 통해 읽을 수 있게 해주는 `게이트웨이`다.
>게이트웨이는 서로 다른 프로토콜을 사용하는 둘 이상을 연결한다. 서로 다른 프로토콜로 말하는 두 서버가 트랜잭션을 완료할 수 있도록 프로토콜 변환기처럼 동작한다.


</div>
</details>
<br>

### 6.2 　  왜 프락시를 사용하는가?　 `jehong`

1. 다음 중 프락시의 사용인 것을 고르세요. (복수 응답 가능)

   a. `taelee` 선생은 `현준` 어린이가 교육 콘텐츠에는 제한 없는 접근은 허용하면서 부적절한 사이트의 접근을 강제로 거부하기 위해 교내에 필터링 프락시를 사용했다.

   b. `secho`는 HTTP스터디에서 관리되는 수많은 웹 서버들에 대한 접근 제어를 중앙화된 프락시 서버에서 설정해  `mihykim` 이 HTTP스터디의 기밀 내용에 접근할 때마다 비밀번호를 요구하도록 했다.
![](https://images.velog.io/images/jehjong/post/2013d7ae-b74d-4778-9317-0a6318ca4a67/image.png)
  
   c. `kukim`은 해외 서버에서 GIF를 더 빠르게 다운받는 등의 더 나은 성능을 위해 트랜스코딩 프락시 사용에 돈을 지불했고 그 결과  `yeha`에게 적절한  GIF를 제 때 보낼 수 있게 되었다.

   d. `daelee`는 컨텐츠의 위치를 찾아내기 위해 웹 서버인 것처럼 위장한 대리 프락시를 사용해 공용 컨텐츠에 대한 느린 웹 서버의 성능을 개선했다.

   

2. 다음 보기에서 골라 빈칸을 채우세요.

   **<보기>** `콘텐츠 라우터`  `보안 방화벽`  `웹캐시`  `트랜스코더`  `웹캐시`  `문서 접근 제어자`  `어린이 필터`  `대리 프락시`  `익명화 프락시`  

   a. 프락시 서버는 `________`을/를 이용해 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도할 수 있다.

   b. 프락시 서버는 인기 있는 문서의 로컬 사본을 근처 `________` 에 저장해 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공한다.

   c. `_________` 프락시는 한국어 텍스트를 스페인어 텍스트로 변환하고 HTML문서를 휴대 전화의 작은 화면에서도 잘 볼 수 있도록 단순한 텍스트로 변환했다.

   ![](https://images.velog.io/images/jehjong/post/ba51a91b-b4bd-446a-9fc8-db2b9f70b487/image.png)

   d. `______________` 은/는 대기업 환경이나 그 외의 분산된 관료 조직에서 감사 추적을 하기 위해 사용될 수 있다.

   

3. `_________` 은/는 HTTP 메시지에서 신원을 식별할 수 있는 특성들을 제거함으로써 개인 정보 보호와 익명성 보장에 기여한다. 개인 정보 보호를 위해 다음 사용자의 메시지에서 무엇을 제거해야하는지 고르세요.

![](https://images.velog.io/images/jehjong/post/c33a5b2c-094f-4ae9-be32-a0dba2870ade/image.png)

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
1. 다음 중 프락시의 사용인 것을 고르세요. (복수 응답 가능)


   > a, b, c, d

2. 다음 보기에서 골라 빈칸을 채우세요.

   **<보기>** `콘텐츠 라우터`  `보안 방화벽`  `웹캐시`  `트랜스코딩`  `웹캐시`  `문서 접근 제어자`  `어린이 필터`  `대리 프락시`  `익명화 프락시`  

   a. 프락시 서버는 `콘텐츠 라우터`을/를 이용해 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도할 수 있다.

   b. 프락시 서버는 인기 있는 문서의 로컬 사본을 근처 `웹캐시` 에 저장해 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공한다.

   c. `트랜스코딩` 프락시는 한국어 텍스트를 스페인어 텍스트로 변환하고 HTML문서를 휴대 전화의 작은 화면에서도 잘 볼 수 있도록 단순한 텍스트로 변환했다.

   ![](https://images.velog.io/images/jehjong/post/ba51a91b-b4bd-446a-9fc8-db2b9f70b487/image.png)
   
   d. `문서 접근 제어자` 은/는 대기업 환경이나 그 외의 분산된 관료 조직에서 감사 추적을 하기 위해 사용될 수 있다.

   

3. `익명화 프락시`은/는 HTTP 메시지에서 신원을 식별할 수 있는 특성들을 제거함으로써 개인 정보 보호와 익명성 보장에 기여한다. 개인 정보 보호를 위해 다음 사용자의 메시지에서 무엇을  변경해야하는지 고르세요.

   > **p.155**
   >
   > c. 사용자의 컴퓨터와 OS 종류를 제거한다
   >
   > d. 사용자의 이메일 주소를 보호하기 위해 헤더를 제거한다
   >
   > e. 어떤 사이트를 거쳐서 방문했는지 알기 어렵게 하기 위해 Referer 헤더를 제거한다
   >
   > f, g. 프로필과 신원 정보를 없애기 위해 Cookie 헤더를 제거한다

![](https://images.velog.io/images/jehjong/post/fd50302f-69c3-4697-bb17-24b32fbee47e/image.png)

</div>
</details>
<br>



### 6.3 　  프락시는 어디에 있는가?　 `taelee`

1. "_____"프락시는  네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹서버에게 자원을 요청할 수 있다.

2. 프락시 계층 콘텐츠 라우팅에서 알맞은 `동적 부모 선택 방식`을 짝지으세요.

   `a.부하 균형`, `b.지리적 인접성에 근거한 라우팅`, `c.프로토콜/타입 라우팅`, `d.유료 서비스 가입자를 위한 라우팅`, 

   1)  어떤 특정 종류의 URI를 갖고 요청한 경우, 특별한 프락시 서버로 보내져 특별하게 처리될 수도 있다. (__)

   2) 자식 프락시는 원 서버의 지역을 담당하는 부모를 선택할 수도 있다. (__)

   3) 자식 프락시는 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프락시를 고른다. (__)


<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


1. "대리(리버스)"프락시는  네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹서버에게 자원을 요청할 수 있다.

2. 프락시 계층 콘텐츠 라우팅에서 알맞은 `동적 부모 선택 방식`을 짝지으세요.

   `a.부하 균형`, `b.지리적 인접성에 근거한 라우팅`, `c.프로토콜/타입 라우팅`, `d.유료 서비스 가입자를 위한 라우팅`, 

   1)  어떤 특정 종류의 URI를 갖고 요청한 경우, 특별한 프락시 서버로 보내져 특별하게 처리될 수도 있다. (c)

   2) 자식 프락시는 원 서버의 지역을 담당하는 부모를 선택할 수도 있다. (b)

   3) 자식 프락시는 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프락시를 고른다. (a)
   </div>
</details>
<br>

### 6.4 　  클라이언트 프락시 설정　 `yeosong`
#### 6.4.1 클라이언트가 프락시 수동으로 설정하기에 대한 설명이다. 옳은 것을 모두 고르시오. (      )

1) 장애시 대체 작동에 대한 지원이 없다.
2) 하나의 프록시 서버만 지정가능하다.
3) 대규모 조직에서 관리 문제를 방지하기 위해 사용한다.

#### 6.4.2  클라이언트가 PAC(Proxy auto-config)파일로 프록시를 설정하기 대한 설명이다. 빈칸을 채우시오. (주관식)

- PAC 파일은 `1)_______`로 작성된 프로그램이다.
- PAC파일의 확장자는 .pac이고, MIME타입은 `2)_________/x-ns-proxy-autoconfig` 이다.
- PAC 파일을 사용하려면, `3)_________`에서 PAC 파일의 URI를 입력하면 된다.
- PAC 파일은 `4)__________________(url, host)` 이라는 함수를 반드시 정의해야한다.

- 아래의 PAC 파일은 http 트랜잭션이 발견될 경우 프락시 없이 직접 연결이 이루어지도록 지시하는 내용이다. (O/X)
~~~
function 4)FindProxyForUrl(url, host) {
if url.substring(0,5) == "http:" {
  return "PROXY http-proxy.yebalja.com:8080";
  } else {
    return "DIRECT";
  }
}
~~~

#### 6.4.3 클라이언트가 WPAD(Web Proxy Auto-Discovery Protocol)로 프락시 설정하기에 대한 설명이다. 옳은 것을 모두 고르시오. (      )

1) WPAD는 웹 브라우저가 직접 프락시 서버 이름을 알아내도록 도와주는 것이 목적이다.
2) WPAD는 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘이다.
3) WPAD는 성공할 때까지 아래의 기법을 순서를 지켜서 하나씩 시도해본다.
  - 동적 호스트 발견 규약 DHCP (Dynamic Host Configuration Protocol)
  - 서비스 위치 규약 [SLP]
  - DNS 잘 알려진 호스트 명
  - DNS SRV 레코드
  - DNS TXT 레코드 안의 서비스 URI
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  

#### 6.4.1 클라이언트가 프락시 수동으로 설정하기에 대한 설명이다. 옳은 것을 모두 고르시오. ( 1, 2 )

1) 장애시 대체 작동에 대한 지원이 없다.
2) 하나의 프록시 서버만 지정가능하다.
3) 대규모 조직에서 관리 문제를 방지하기 위해 사용한다. (X)
  - 대규모 조직을 관리하기에는 정적인 대응이며, 다양한 대응 옵션이 없기 때문에 부적절하다.

#### 6.4.2  클라이언트가 PAC(Proxy auto-config)파일로 프록시를 설정하기 대한 설명이다. 빈칸을 채우시오. (주관식)

- PAC 파일은 `1) 자바스크립트`로 작성된 프로그램이다.
- PAC파일의 확장자는 .pac이고, MIME타입은 `2) application/x-ns-proxy-autoconfig` 이다.
- PAC 파일을 사용하려면, `3)브라우저 설정`에서 PAC 파일의 URI를 입력하면 된다.
- PAC 파일은 `4)FindProxyForUrl(url, host)` 이라는 함수를 반드시 정의해야한다.

- 아래의 PAC 파일은 http 트랜잭션이 발견될 경우 프락시 없이 직접 연결이 이루어지도록 지시하는 내용이다. (X)
~~~
function 4)FindProxyForUrl(url, host) {
if url.substring(0,5) == "http:" {
  return "PROXY http-proxy.yebalja.com:8080";
  } else {
    return "DIRECT";
  }
}
~~~
  - PROXY http-proxy.yebalja.com:8080를 사용하도록 지시하고 있다.
  - 반환값 PROXY host:port는 지정한 프록시를 사용해야한다는 뜻이다. (163p)

참고: [IEAK 11에서 프록시 자동 구성(.pac) 파일 사용 예제 보기](https://docs.microsoft.com/ko-kr/internet-explorer/ie11-ieak/proxy-auto-config-examples)

#### 6.4.3 클라이언트가 WPAD(Web Proxy Auto-Discovery Protocol)로 프락시 설정하기에 대한 설명이다. 옳은 것을 모두 고르시오. ( 2, 3 )

1) WPAD는 웹 브라우저가 직접 프락시 서버 이름을 알아내도록 도와주는 것이 목적이다. (X)
  - WPAD는 웹 브라우저가 근처의 프락시를 찾아 사용할 수 있게 해주는 방법을 제공하는 것이 목적이다.
  - 직접 서버 이름을 알아내지는 않는데, 그렇게 하면 PAC 파일에 의해 제공되는 추가적인 기능들을 활용할 수 없기 때문이다.(541p)
2) WPAD는 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘이다. (O) (163p)
3) WPAD는 성공할 때까지 아래의 기법을 순서를 지켜서 하나씩 시도해본다. (O) (163p)
  - 동적 호스트 발견 규약 DHCP (Dynamic Host Configuration Protocol)
  - 서비스 위치 규약 [SLP]
  - DNS 잘 알려진 호스트 명
  - DNS SRV 레코드
  - DNS TXT 레코드 안의 서비스 URI

</div>
</details>
<br>

### 6.5 　  프락시 요청의 미묘한 특징들　 `hylee`
1. 클라이언트가 웹 서버로 보낼 때 불필요한 정보 발송을 피하기 위해 스킴과 호스트, 포트번호가 없는 부분 URI만 보내고 프락시로 보낼때는 완전한 URI를 보낸다. (O/X)
2. 부분 URI로 받을때의 문제점을 가상 호스팅 웹 서버는 호스트와 포트에 대한 정보가 담겨있는 (______)를 요구함으로써 문제를 해결했다. (주관식)
3. 클라이언트는 자신이 프락시와 대화하고 있음을 항상 알 수 있다. (O/X)
4. 프락시는 다음 홉으로 보내기 전에 URI에서 기본 포트가 명시되어 있지 않을 때 기본 포트인 :80으로 명시하거나 잘못 사용한 예약된 글자가 있을때 올바르게 이스케이프하여 교체하도록 하는 정규화 기능을 해주는게 좋다.(O/X)
5. 프락시가 없는 URI분석에서 브라우저는 호스트 명 자동확장을 (한다/ 안 한다)
6. 명시적인 프락시를 사용할때의 URI 분석에서 브라우저는 호스트 명 자동확장을 (한다/ 안 한다)
7. 프락시가 없는 브라우저와 인터셉트 프락시를 이용한 브라우저는 동작이나 서버로의 커넥션이 만들어졌을 때에도 별 차이가 없다. (O/X)

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. (O) - 
2. (Host 헤더) - p.165 
3. (X) 몇몇 프락시는 클라이언트에게는 보이지 않을 수 있기 때문이다. ex. 인터셉트 프락시와 리버스 프락시 - p.166~167
4. (X) 이렇게 무해해 보이는 사소한 변경이라도 다운스트림 서버와 상호 운용성 문제를 일으킬 수 있다. - p.168
5. (한다) - 호스트 명 확장 기능을 지원하는 브라우저는 입력한 호스트 명을 전체 호스트 명으로 확장하는 기능을 제공한다.
6. (안한다) 브라우저의 URI가 프록시를 그냥 지나쳐버리기 때문이다.
7. (X) 서버로 커넥션이 만들어졌을때 분명한 차이가 발생하는데 이건 인터셉트 프락시를 사용하고 있는 브라우저는 죽은 서버의 IP 주소를 탐지할 수 없기때문에 프락시쪽에서 죽은 서버의 DNS분석에 대한 장애 허용이 달려있기 때문이다.(명시적인 프락시로 설정되어있을때도 장애 허용이 프락시에게 달려있음) - p.171~172





</div>
</details>
<br>

### 6.6 　  메시지 추적　 `yeha`
1. Via 헤더 필드는 개행으로 구분된 경유지(waypoint)의 목록이다. (O/X)  
2. 모든 Via waypoint는 4개의 구성 요소(프로토콜 이름, 프로토콜 버전, 노드 이름, 코멘트)로 구성되어 있다. (O/X)  
3. 요청 메시지와 응답 메시지 모두 프락시를 지나므로 Via 헤더를 가진다. (O/X)  
4. 응답 Via 헤더는 언제나 요청 Via 헤더와 반대다. (O/X)  
5. 응답 메시지가 프락시를 통과할 때, 프락시는 Via 항목을 추가한다. Server 헤더는 원 서버를 위해 존재하므로 수정하면 안 된다. (O/X)   
6. Server 응답 헤더 필드는 원 서버에 의해 사용되는 (______)를 알려준다.
      > Server: Apache/1.3.14 (Unix) PHP/4.0.4  
        Server: Netscape-Enterprise/4,1  
      > Server: Microsoft-IIS/5.0   
7. 프락시 서버가 네트워크 방화벽의 일부인 경우 프락시는 Via 문자열 안에 방화벽 뒤 호스트의 이름과 포트를 전달하면 안 된다. (O/X)  
7-1. 방화벽 뒤 네트워크 아키텍처에 대한 정보가 나쁘게 이용될 수 있기 때문이다. (O/X)  
8. TRACE 요청이 목적지 서버에 도착 시, 서버는 요청 메시지를 검토한 후 HTTP 응답 메시지에 상태(e.g. 200 OK)를 추가하여 송신자에게 돌려보낸다. (O/X)  

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. Via 헤더 필드는 개행으로 구분된 경유지의 목록이다. (X)  
  => 쉼표로 구분한다  
2. 모든 Via waypoint는 4개의 구성 요소(프로토콜 이름, 프로토콜 버전, 노드 이름, 코멘트)로 구성되어 있다. (X)  
  => 4개의 구성요소는 맞으나 모두 필수는 아니다. (프로토콜 이름(선택), 프로토콜 버전(필수), 노드 이름(필수), 코멘트(선택))   
3. 요청 메시지와 응답 메시지 모두 프락시를 지나므로 Via 헤더를 가진다. (O)   
4. 응답 Via 헤더는 언제나 요청 Via 헤더와 반대다. (O)  
  => p.175 그림 참조   
5. 응답 메시지가 프락시를 통과할 때, 프락시는 Via 항목을 추가한다. Server 헤더는 원 서버를 위해 존재하므로 수정하면 안 된다. (O)   
6. Server 응답 헤더 필드는 원 서버에 의해 사용되는 (소프트웨어)를 알려준다.  
7. 프락시 서버가 네트워크 방화벽의 일부인 경우 프락시는 Via 문자열 안에 방화벽 뒤 호스트의 이름과 포트를 전달하면 안 된다. (O)    
  => 보통 명시적으로 이 동작이 켜져 있지 않은 이상 정확한 호스트명을 전달은 X  
7-1. 방화벽 뒤 네트워크 아키텍처에 대한 정보가 나쁘게 이용될 수 있기 때문이다. (O)   
  => p.176 하단 참고  
8. TRACE 요청이 목적지 서버에 도착 시, 서버는 요청 메시지를 검토한 후 HTTP 응답 메시지에 상태(e.g. 200 OK)를 추가하여 송신자에게 돌려보낸다. (X)   
  => p.177 TRACE 요청이 목적지 서버에 도착 시, 서버는 전체 요청 메시지를 HTTP 응답 메시지 본문에 포함시켜 송신자에게 그대로 돌려보낸다.   
</div>
</details>
<br>

### 6.7 　  프락시 인증　 `kukim`
- 프락시 서버는 접근 제어 장치로 제공될 수 있다. (O / X)
- 407 상태 코드는 무엇인가요? (주관식)
- 프락시 인증은 프락시가 연쇄상에 여러 개 있을 때 잘 동작한다. (O / X)
- +ɑ) 프락시 서버가 클라이언트에게 적절하지 않는 인증 정보를 수신한다면 어떤 상태코드를 반환하는가?

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 프락시 서버는 접근 제어 장치로 제공될 수 있다. (O)
  - HTTP는 사용자가 유효한 접근 권한 자격을 프락시에 제출하지 않는 한 콘텐츠에 대한 요청을 차단하는 프락시 인증이라는 메커니즘을 정의하고 있다.
- 407 상태 코드는 무엇인가요? (주관식)
  - 407 proxy Authorization Required (프록시 권한부여 요청 상태메세지), 클라이언트가 서버에 요청했을 때 중간에 있는 프락시 서버는 접근 자격을 요구하는 407 상태코드를 응답한다.
  - 클라이언트는 407 응답을 받게되면 요구되는 자격을 획득하는 proxy-authorization 헤더필드에 담아서 요청을 다시 보낸다.
- 프락시 인증은 프락시가 연쇄상에 여러 개 있을 때 잘 동작한다. (X)
  - X : 연쇄상에 있으면 인증하기 까다롭다. 
- +ɑ) 프락시 서버가 클라이언트에게 적절하지 않는 인증 정보를 수신한다면 어떤 상태코드를 반환하는가?
  - 403 Forbidden 상태코드 

참고 : HTTP 인증, https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication

</div>
</details>
<br>

### 6.8 　  프락시 상호운용성　 `kukim`
- 프락시 서버는 클라이언트나 서버에게 받은 헤드 필드들은 자신이 알지 못하는 것이어도 반드시 그대로 전달해야 한다. (O)
- 프락시 서버는 같은 이름의 헤더 필드가 여러개 있는 경우에는 순서에 상관없이 전달해도 된다. (X)
- OPTIONS 메서드 요청 중 서버 전체 능력에 대해 묻는 메세지는 무엇인가? 괄호를 채우시오.  
보기 : `ALL`, `*`, `개행문자`  
`OPTIONS (    ) HTTP/1.1`
- OPTIONS 메서드의 서버 전체 능력에 대해 묻는 요청 메세지에 대한 응답 메세지이다. 괄호에 들어가는 헤더는 무엇인가? (단답식)
```
HTTP/1.1 200 OK
(    ) : GET, PUT, POST, OPTIONS
```
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 프락시 서버는 클라이언트나 서버에게 받은 헤드 필드들은 자신이 알지 못하는 것이어도 반드시 그대로 전달해야 한다. (O / X)
  - 프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 한다. (프락시 서버보다 버전이 높은 새로운 헤더일 수 있고, 특정 애플리케이션을 위해 만들어진 것 일 수 있다. 
- 프락시 서버는 같은 이름의 헤더 필드가 여러개 있는 경우에는 순서에 상관없이 전달해도 된다. (O / X)
  - 상대적인 순서를 반드시 유지해야 한다. (헤더 필드들의 순서가 데이터에 영향을 미치기 때문)
- OPTIONS 메서드 요청 중 서버 전체 능력에 대해 묻는 메세지는 무엇인가? 괄호를 채우시오.  
보기 : `ALL`, `*`, `개행문자`  
`OPTIONS ( * ) HTTP/1.1`
- OPTIONS 메서드의 서버 전체 능력에 대해 묻는 요청 메세지에 대한 응답 메세지이다. 괄호에 들어가는 헤더는 무엇인가? (단답식)
```
HTTP/1.1 200 OK
( Allow ) : GET, PUT, POST, OPTIONS
```

</div>
</details>
<br>
