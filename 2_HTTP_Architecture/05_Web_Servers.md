## 05장 :octopus: 웹 서버

[5.1　다채로운 웹 서버](#51--다채로운-웹-서버-junslee) <br>
[5.2　간단한 펄 웹 서버](#52--간단한-펄-웹-서버-junslee) <br>
[5.3　진짜 웹 서버가 하는 일](#53--진짜-웹-서버가-하는-일-mihykim) <br>
[5.4　단계 1: 클라이언트 커넥션 수락](#54--단계-1-클라이언트-커넥션-수락-mihykim)<br>
[5.5　단계 2: 요청 메시지 수신](#55--단계-2-요청-메시지-수신-mihykim) <br>
[5.6　단계 3: 요청 처리](#56--단계-3-요청-처리-daelee) <br>
[5.7　단계 4: 리소스의 매핑과 접근](#57--단계-4-리소스의-매핑과-접근-daelee) <br>
[5.8　단계 5: 응답 만들기](#58--단계-5-응답-만들기-secho) <br>
[5.9　단계 6: 응답 보내기](#59--단계-6-응답-보내기-secho) <br>
[5.10　단계 7: 로깅](#510--단계-7-로깅-secho) <br>
<br>

### 5.1　  다채로운 웹 서버　 `junslee`
1.'웹 서버'라는 용어가 가리키는 내용을 모두 고르세요. (_____)<br>
  (1) 웹 브라우저와 같은 클라이언트로 부터 HTTP 요청을 받아들이고, HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램<br>
  (2) 보기 (1)번의 기능을 제공하는 컴퓨터 프로그램을 실행하는 컴퓨터<br><br>

2.웹 서버의 공통된 기능에 해당하는 사항을 모두 고르세요. (_____)<br>
  (1) 동적 콘텐츠 관리(클라이언트의 요청에 따라 시시각각 변하는 동적 웹페이지를 제공.)<br>
  (2) 대역폭 제한(네트워크의 포화 상태를 방지하기 위한 응답 속도 제한.)<br>
  (3) 가상 호스팅(하나의 IP주소를 사용하는 많은 웹 사이트들을 지원.)<br>
  (4) 인증(쿠키와 세션)<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
정답은 (1), (2)
'웹 서버'는 크게 소프트웨어(위 보기의 (1)에 해당)와 하드웨어(보기의 (2)에 해당)로 나뉠 수 있다.
1번 보기, 2번 보기 모두 웹 서버를 지칭하기는 하지만, 우리가 흔히 말하는 '웹 서버'는 웹 브라우저로 부터 HTTP요청을 받아들이고, 
HTML문서와  같은 웹 페이지에서 흔히 찾아 볼 수 있는 자료 콘텐츠에 따라  HTTP응답을 해주는 프로그램을 말한다.

정답은 (2), (3), (4)
웹서버의 기능은 동적 콘텐츠 관리가 아닌 정적 콘텐츠 관리이다.
2번 보기의 대역폭 스로틀링 또는 대역폭 제한이란 인터넷 서비스 공급자가 의도적으로 인터넷 서비스를 느리게 하는 것을 의미한다.
3번 보기의 가상 호스팅에 대한 설명 https://medium.com/@jw02048/가상-호스팅이란-a9898dacf738 , 
호스팅에 대한 설명 https://www.dotname.co.kr/hosting/web/guide

</div>
</details>
<br>

### 5.2　  간단한 펄 웹 서버　 `junslee`
1. 'type-o-serve'라는 작은 펄 프로그램은 클라이언트와 프락시 간의 상호작용 테스트를 할때 이용되는 유용한 진단 도구이다.<br>
아래는 'type-o-serve'프로그램의 동작들을 순서와 상관없이 나열한 것이다. ( 1 )번 이후 동작순서에 맞게 정렬하세요.<br>

__`( 1 )`__ 사용할 포트(번호)를 정한다.<br>
__`(　 )`__ 빈 줄이 나올 때까지 요청 메시지를 읽어서 화면에 출력한다.<br>
__`(　 )`__ 로컬 TCP 소켓을 생성하고 커넥션을 기다리도록 (listen)을 설정한다.<br>
__`(　 )`__ 누구로부터의 커넥션인지 출력한다.<br>
__`(　 )`__ 시작 메시지를 출력한다. (커넥션을 받을 준비가 됐다는 내용을 콘솔에 출력한다.)<br>
__`(　 )`__ 클라이언트로 부터 커넥션을 기다린다.<br>
__`(　 )`__ 응답 메시지를 위한 프롬프트를 만들고, 응답줄을 입력받는다. ("." 하나만으로 되어 있는 줄이 입력되기 전까지, 입력된 줄을 클라이언트에게 보낸다.)<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
 정답은 (1)-(6)-(2)-(5)-(3)-(4)-(7) __p128,129__
 참고할 내용 https://recipes4dev.tistory.com/153
 
 그림. 참고
 <p align="center"><img src="https://t1.daumcdn.net/cfile/tistory/995C23465C7DD7E30B" width="700" height="500"></p>

</div>
</details>
<br>

### 5.3　  진짜 웹 서버가 하는 일　 `mihykim`
<p align="center"><img src="https://user-images.githubusercontent.com/60066472/89006440-bcacd600-d341-11ea-973e-f4424c2b2b01.png" width="700"></p>

- 위 그림을 참고하여 빈칸에 알맞은 순서를 기입해주세요 (1-7)
  - 리소스에 접근한다 _(메세지에서 지정한 리소스에 접근한다)_ : __`(　)`__
  - 커넥션을 맺는다 _(클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다)_ : __`(　)`__
  - 트랜잭션을 로그로 남긴다 _(로그파일에 트랜잭션 완료에 대한 기록을 남긴다)_ : __`(　)`__
  - 요청을 받는다 _(HTTP 요청 메세지를 네트워크로붜 읽어들인다)_ : __`(　)`__
  - 응답을 만든다 _(올바른 헤더를 포함한 HTTP 응답 메세지를 생성한다)_ : __`(　)`__
  - 요청을 처리한다 _(요청 메세지를 해석하고 행동을 취한다)_ : __`(　)`__
  - 응답을 보낸다 _(응답을 클라이언트에게 돌려준다)_ : __`(　)`__
  
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- __p130__
- 리소스에 접근한다 _(메세지에서 지정한 리소스에 접근한다)_ : __`(4)`__
- 커넥션을 맺는다 _(클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다)_ : __`(1)`__
- 트랜잭션을 로그로 남긴다 _(로그파일에 트랜잭션 완료에 대한 기록을 남긴다)_ : __`(7)`__
- 요청을 받는다 _(HTTP 요청 메세지를 네트워크로붜 읽어들인다)_ : __`(2)`__
- 응답을 만든다 _(올바른 헤더를 포함한 HTTP 응답 메세지를 생성한다)_ : __`(5)`__
- 요청을 처리한다 _(요청 메세지를 해석하고 행동을 취한다)_ : __`(3)`__
- 응답을 보낸다 _(응답을 클라이언트에게 돌려준다)_ : __`(6)`__

</div>
</details>
<br>

### 5.4　  단계 1: 클라이언트 커넥션 수락　 `mihykim`
- 특정 커넥션의 경우, 웹서버가 반드시 커넥션을 받아들여야 하기도 한다. __( O / X )__
- 새 커넥션이 맺어지고 받아들여지면 웹 서버는 새 커넥션을 커넥션 목록에 추가하고 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 한다 __( O / X )__
- 웹 서버는 역방향 DNS 또는 ident 프로토콜을 통해 사용자를 알아낼 수 있는데, 두 방법 모두 HTTP 트랜잭션 지연과는 관련이 없다. __( O / X )__
- 어떤 사용자이름이 HTTP 커넥션을 초기화했는지 서버가 알 수 있게 해주는 IETF ident 프로토콜은, 클라이언트 사용자이름의 노출로 인한 프라이버시 침해 우려가 있다. __( O / X )__

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 특정 커넥션의 경우, 웹서버가 반드시 커넥션을 받아들여야 하기도 한다.  __( X )__  __p131__
  - 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다.
  - 어떤 웹 서버들은 클라이언트의 IP주소나 호스트 명이 인가되지 않았거나 악의적이라고 알려진 것인 경우 커넥션을 닫는다.
- 새 커넥션이 맺어지고 받아들여지면 웹 서버는 새 커넥션을 커넥션 목록에 추가하고 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 한다 __( O )__  __p131__
- 웹 서버는 역방향 DNS 또는 ident 프로토콜을 통해 사용자를 알아낼 수 있는데, 두 방법 모두 HTTP 트랜잭션 지연과는 관련이 없다. __( X )__  __p132, p133__
  - 호스트명 룩업은 꽤 시간이 많이 걸릴 수 있어 웹 트랜잭션을 느려지게 할 수 있음을 미리 경고해두겠다.
  - ident 프로토콜은 HTTP 트랜잭션을 유의미하게 지연시킨다.
- 어떤 사용자이름이 HTTP 커넥션을 초기화했는지 서버가 알 수 있게 해주는 IETF ident 프로토콜은, 클라이언트 사용자이름의 노출로 인한 프라이버시 침해 우려가 있다. __( O )__  __p133__
  - [IETF](https://ko.wikipedia.org/wiki/%EA%B5%AD%EC%A0%9C_%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%91%9C%EC%A4%80%ED%99%94_%EA%B8%B0%EA%B5%AC)(국제 인터넷 표준화 기구, Internet Engineering Task Force)
  - [ident 프로토콜](https://en.wikipedia.org/wiki/Ident_protocol)
      - 특정 TCP 커넥션의 사용자를 식별하는 데 도움이되는 인터넷 프로토콜.

</div>
</details>
<br>

### 5.5　  단계 2: 요청 메시지 수신　 `mihykim`
- 웹 서버는 스페이스, CRLF 등으로 이미 파싱된 메세지 단위로 데이터를 받아서, 별도로 파싱 과정을 거치거나 일부를 버퍼에 저장해둘 필요는 없다. __( O / X )__
- 웹 클라이언트가 보낸 요청 메세지의 내용 중, 줄바꿈 또는 빈줄을 표현하기 위해 CRLF가 아닌 LF를 보낸다면 웹 서버는 줄바꿈을 제대로 인식하지 못할 것이다. __( O / X )__

<p align="center"><img src="https://user-images.githubusercontent.com/60066472/89037975-71fb8000-d37a-11ea-8571-05a2755f8ef1.jpg" width="600"></p>

- 위 그림을 참고하여 보기의 특성에 맞는 웹서버의 아키텍처를 기입해주세요 (a-d)
    - CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 멀티플렉싱을 결합한다 __(　　)__
    - 한 트랜잭션이 완료된 후에야 다음 커넥션을 처리할 수 있어 처리 도중에 모든 다른 커넥션은 무시된다 __(　　)__
    - 여러 커넥션을 동시에 처리할 수 있지만 그로 인해 만들어진 수많은 프로세스/스레드로 리소스 낭비가 과해질 수 있다 __(　　)__
    - 어떤 커넥션에 대해 작업을 수행하는 것은 그 커넥션에 실제로 할일이 있을 때 뿐이다 __(　　)__

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 웹 서버는 스페이스, CRLF 등으로 이미 파싱된 메세지 단위로 데이터를 받아서, 별도로 파싱 과정을 거치거나 일부를 버퍼에 저장해둘 필요는 없다. __( X )__ __p134__
  - 파싱이란?
    - 언어학에서 구문 분석 또는 '파싱'은 문장을 그것을 이루고 있는 구성 성분으로 분해하고 그들 사이의 위계 관계를 분석하여 문장의 구조를 결정하는 것을 말한다.
    - 컴퓨터 과학에서 파싱((syntactic) parsing)은 일련의 문자열을 의미있는 토큰(token)으로 분해하고 이들로 이루어진 파스 트리(parse tree)를 만드는 과정을 말한다.
  - 웹 서버는 입력 데이터를 네트워크로부터 불규칙적으로 받는다. 
  - 웹 서버는 파싱해서 이해하는 것이 가능한 수준의 분량을 확보할 때까지 데이터를 네트워크로부터 읽어서 메세지 일부분을 메모리에 임시로 저장해둘 필요가 있다.
- 웹 클라이언트가 보낸 요청 메세지의 내용 중, 줄바꿈 또는 빈줄을 표현하기 위해 CRLF가 아닌 LF를 보낸다면 웹 서버는 줄바꿈을 제대로 인식하지 못할 것이다. __( X )__  __p134__
  - 많은 웹 서버들이 LF와 CRLF 모두를 줄바꿈 문자로 인식한다. 줄의 끝을 표현하기 위해 실수로 LF를 보내는 클라이언트들도 종종 있기 때문이다.

<p align="center"><img src="https://user-images.githubusercontent.com/60066472/89037975-71fb8000-d37a-11ea-8571-05a2755f8ef1.jpg" width="600"></p>

- 위 그림을 참고하여 보기의 특성에 맞는 웹서버의 아키텍처를 기입해주세요 (a-d)
    - CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 멀티플렉싱을 결합한다 __(d)__
    - 한 트랜잭션이 완료된 후에야 다음 커넥션을 처리할 수 있어 처리 도중에 모든 다른 커넥션은 무시된다 __( a )__
    - 여러 커넥션을 동시에 처리할 수 있지만 그로 인해 만들어진 수많은 프로세스/스레드로 리소스 낭비가 과해질 수 있다 __(b)__
    - 어떤 커넥션에 대해 작업을 수행하는 것은 그 커넥션에 실제로 할일이 있을 때 뿐이다 __(c,d)__

</div>
</details>
<br>

### 5.6　  단계 3: 요청 처리　 `daelee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 5.7　  단계 4: 리소스의 매핑과 접근　 `daelee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### 5.8　  단계 5: 응답 만들기　 `secho`

##### 1번. 보기에 따라 고르시오. 

(응답 메소드, 응답 메시지, 요청 메소드, 요청 메시지)

- 서버가 리소스를 식별하면 서버는 (..... _)로 서술되는 동작을 수행한 뒤 (_ .....)를 반환한다.


##### 2번.  보기에 따라 고르시오.

(Content-Length, Content-Type, 리소스, MIME, 객체)

- 트랜잭션이 응답 본문을 생성한다면, 그 내용을 응답 메시지와 함께 돌려보낸다. 응답 메시지는 다음을 포함한다.
  - 응답 본문의 (.....)타입을 서술하는 (.....)헤더
  - 응답 본문의 길이를 서술하는 (.....)헤더
  - 실제 응답 본문의 내용


##### 3번. 

- 웹 서버는 각 파일의 MIME타입을 알아낼 수 없다. ( O / X )
- 특정 파일이 특정 MIME타입을 갖게 웹서버를 설정할 수 없다.( O / X)


##### 4번. 다음 상황에 사용되는 응답은?

- 새 URL이 부여되어 이름이 바뀌거나 새로운 위치로 리소스가 옮겨졌을 때
- 리소스가 임시로 옮겨졌을 때
- 상태 정보를 포함한 뚱뚱한 URL을 생성하여 처리할 때
- 과부하된 서버가 요청을 받을 때
- 클라이언트에 대한 정보를 가진 다른 서버가 있을 때.
- 클라이언트가 URL요청을 할 때 빗금(/)을 빠트렸을 때.


##### 5번. 세초는 영구히 리소스가 옮겨진 `/main`경로로 `redirection`되었다. 세초가 서버로부터 받은 HTTP 응답 메시지는?

```
...
Status Code: (1.빈칸) Moved Permanently
Request Headers
Location: (2.빈칸)
```



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


##### 1번. 보기에 따라 고르시오. 

(응답 메소드, 응답 메시지, 요청 메소드, 요청 메시지)

- 서버가 리소스를 식별하면 서버는 (**요청메소드** _)로 서술되는 동작을 수행한 뒤 (**응답 메시지**)를 반환한다.


##### 2번.  보기에 따라 고르시오.

(Content-Length, Content-Type, 리소스, MIME, 객체)

- 트랜잭션이 응답 본문을 생성한다면, 그 내용을 응답 메시지와 함께 돌려보낸다. 응답 메시지는 다음을 포함한다.
  - 응답 본문의 (**MIME**)타입을 서술하는 (**Content-Type**)헤더
  - 응답 본문의 길이를 서술하는 (**Content_Length**)헤더
  - 실제 응답 본문의 내용


##### 3번. 

- 웹 서버는 각 파일의 MIME타입을 알아낼 수 없다. ( O / **X** )
  - 웹 서버는 파일 내용을 검사해, 알려진 패턴에 대한 매직파일에 해당하는 패턴이 있는지 찾아서 MIME 타입을 알아낼 수 있다.
- 특정 파일이 특정 MIME타입을 갖게 웹서버를 설정할 수 없다.( **O** / X)
  - 파일 확장자나 내용에 상관없이 어떤 MIME타입을 갖도록 웹서버를 설정할 수 있다.


##### 4번. 다음 상황에 사용되는 응답은?

- 새 URL이 부여되어 이름이 바뀌거나 새로운 위치로 리소스가 옮겨졌을 때
- 리소스가 임시로 옮겨졌을 때
- 상태 정보를 포함한 뚱뚱한 URL을 생성하여 처리할 때
- 과부하된 서버가 요청을 받을 때
- 클라이언트에 대한 정보를 가진 다른 서버가 있을 때.
- 클라이언트가 URL요청을 할 때 빗금(/)을 빠트렸을 때.

**리다이렉트**


##### 5번. 세초는 영구히 리소스가 옮겨진 `/main`경로로 `redirection`되었다. 세초가 서버로부터 받은 HTTP 응답 메시지는?

```
...
Status Code: 301 Moved Permanently
Request Headers
Location: /main
```



</div>
</details>
<br>

### 5.9　  단계 6: 응답 보내기　 `secho`


##### 6번

- 서버는 여러 클라이언트에 많은 커넥션을 가질 수 있다 ( O / X )
- 지속 커넥션인 경우 서버는 Content-Length 헤더를 바르게 계산하기 위해 커넥션을 유지한다. ( O / X )
- 비지속 커넥션인 경우 서버가 모든 메시지를 전송했을 때 서버의 커넥션을 닫는다. ( O / X )

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- 서버는 여러 클라이언트에 많은 커넥션을 가질 수 있다 ( **O** / X )
- 지속 커넥션인 경우 서버는 Content-Length 헤더를 바르게 계산하기 위해 커넥션을 유지한다. ( **O** / X )
- 비지속 커넥션인 경우 서버가 모든 메시지를 전송했을 때 서버의 커넥션을 닫는다. ( **O** / X )

</div>
</details>
<br>

### 5.10　  단계 7: 로깅　 `secho`

##### 7번
- 트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지 로그를 로그파일에 기록하지 않는다 (O / X)
- [nodeJS 로그파일 생성하는 법](https://velog.io/@pizzu/nodejs-%EB%A1%9C%EA%B7%B8%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1-%ED%95%98%EB%8A%94-%EB%B2%95)

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


- 트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지 로그를 로그파일에 기록하지 않는다 (O / **X**)

  - 기록함!

</div>
</details>
<br>

[맨위로](#05장-octopus-웹-서버)

