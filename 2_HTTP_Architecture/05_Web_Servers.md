## 05장 :octopus: 웹 서버

[5.1　다채로운 웹 서버](#51--다채로운-웹-서버-junslee) <br>
[5.2　간단한 펄 웹 서버](#52--간단한-펄-웹-서버-junslee) <br>
[5.3　진짜 웹 서버가 하는 일](#53--진짜-웹-서버가-하는-일-mihykim) <br>
[5.4　단계 1: 클라이언트 커넥션 수락](#54--단계-1-클라이언트-커넥션-수락-mihykim)<br>
[5.5　단계 2: 요청 메시지 수신](#55--단계-2-요청-메시지-수신-mihykim) <br>
[5.6　단계 3: 요청 처리](#56--단계-3-요청-처리-daelee) <br>
[5.7　단계 4: 리소스의 매핑과 접근](#57--단계-4-리소스의-매핑과-접근-daelee) <br>
[5.8　단계 5: 응답 만들기](#58--단계-5-응답-만들기-secho) <br>
[5.9　단계 6: 응답 보내기](#59--단계-6-응답-보내기-secho) <br>
[5.10　단계 7: 로깅](#510--단계-7-로깅-secho) <br>
<br>

### 5.1　  다채로운 웹 서버　 `junslee`
1.'웹 서버'라는 용어가 가리키는 내용을 모두 고르세요. (_____)<br>
  (1) 웹 브라우저와 같은 클라이언트로 부터 HTTP 요청을 받아들이고, HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램<br>
  (2) 보기 (1)번의 기능을 제공하는 컴퓨터 프로그램을 실행하는 컴퓨터<br><br>

2.웹 서버의 공통된 기능에 해당하는 사항을 모두 고르세요. (_____)<br>
  (1) 동적 콘텐츠 관리(클라이언트의 요청에 따라 시시각각 변하는 동적 웹페이지를 제공.)<br>
  (2) 대역폭 제한(네트워크의 포화 상태를 방지하기 위한 응답 속도 제한.)<br>
  (3) 가상 호스팅(하나의 IP주소를 사용하는 많은 웹 사이트들을 지원.)<br>
  (4) 인증(쿠키와 세션)<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
정답은 (1), (2)
'웹 서버'는 크게 소프트웨어(위 보기의 (1)에 해당)와 하드웨어(보기의 (2)에 해당)로 나뉠 수 있다.
1번 보기, 2번 보기 모두 웹 서버를 지칭하기는 하지만, 우리가 흔히 말하는 '웹 서버'는 웹 브라우저로 부터 HTTP요청을 받아들이고, 
HTML문서와  같은 웹 페이지에서 흔히 찾아 볼 수 있는 자료 콘텐츠에 따라  HTTP응답을 해주는 프로그램을 말한다.

정답은 (2), (3), (4)
웹서버의 기능은 동적 콘텐츠 관리가 아닌 정적 콘텐츠 관리이다.
2번 보기의 대역폭 스로틀링 또는 대역폭 제한이란 인터넷 서비스 공급자가 의도적으로 인터넷 서비스를 느리게 하는 것을 의미한다.
3번 보기의 가상 호스팅에 대한 설명 https://medium.com/@jw02048/가상-호스팅이란-a9898dacf738 , 
호스팅에 대한 설명 https://www.dotname.co.kr/hosting/web/guide

</div>
</details>
<br>

### 5.2　  간단한 펄 웹 서버　 `junslee`
1. 'type-o-serve'라는 작은 펄 프로그램은 클라이언트와 프락시 간의 상호작용 테스트를 할때 이용되는 유용한 진단 도구이다.<br>
아래는 'type-o-serve'프로그램의 동작들을 순서와 상관없이 나열한 것이다. ( 1 )번 이후 동작순서에 맞게 정렬하세요.<br>

__`( 1 )`__ 사용할 포트(번호)를 정한다.<br>
__`(　 )`__ 빈 줄이 나올 때까지 요청 메시지를 읽어서 화면에 출력한다.<br>
__`(　 )`__ 로컬 TCP 소켓을 생성하고 커넥션을 기다리도록 (listen)을 설정한다.<br>
__`(　 )`__ 누구로부터의 커넥션인지 출력한다.<br>
__`(　 )`__ 시작 메시지를 출력한다. (커넥션을 받을 준비가 됐다는 내용을 콘솔에 출력한다.)<br>
__`(　 )`__ 클라이언트로 부터 커넥션을 기다린다.<br>
__`(　 )`__ 응답 메시지를 위한 프롬프트를 만들고, 응답줄을 입력받는다. ("." 하나만으로 되어 있는 줄이 입력되기 전까지, 입력된 줄을 클라이언트에게 보낸다.)<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
 
 정답은 (1)-(6)-(2)-(5)-(3)-(4)-(7) __p128,129__
 참고할 내용 https://recipes4dev.tistory.com/153
 
 그림. 참고
 <p align="center"><img src="https://t1.daumcdn.net/cfile/tistory/995C23465C7DD7E30B" width="700" height="500"></p>

</div>
</details>
<br>

### 5.3　  진짜 웹 서버가 하는 일　 `mihykim`
<p align="center"><img src="https://user-images.githubusercontent.com/60066472/89006440-bcacd600-d341-11ea-973e-f4424c2b2b01.png" width="700"></p>

- 위 그림을 참고하여 빈칸에 알맞은 순서를 기입해주세요 (1-7)
  - 리소스에 접근한다 _(메세지에서 지정한 리소스에 접근한다)_ : __`(　)`__
  - 커넥션을 맺는다 _(클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다)_ : __`(　)`__
  - 트랜잭션을 로그로 남긴다 _(로그파일에 트랜잭션 완료에 대한 기록을 남긴다)_ : __`(　)`__
  - 요청을 받는다 _(HTTP 요청 메세지를 네트워크로붜 읽어들인다)_ : __`(　)`__
  - 응답을 만든다 _(올바른 헤더를 포함한 HTTP 응답 메세지를 생성한다)_ : __`(　)`__
  - 요청을 처리한다 _(요청 메세지를 해석하고 행동을 취한다)_ : __`(　)`__
  - 응답을 보낸다 _(응답을 클라이언트에게 돌려준다)_ : __`(　)`__
  
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- __p130__
- 리소스에 접근한다 _(메세지에서 지정한 리소스에 접근한다)_ : __`(4)`__
- 커넥션을 맺는다 _(클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다)_ : __`(1)`__
- 트랜잭션을 로그로 남긴다 _(로그파일에 트랜잭션 완료에 대한 기록을 남긴다)_ : __`(7)`__
- 요청을 받는다 _(HTTP 요청 메세지를 네트워크로붜 읽어들인다)_ : __`(2)`__
- 응답을 만든다 _(올바른 헤더를 포함한 HTTP 응답 메세지를 생성한다)_ : __`(5)`__
- 요청을 처리한다 _(요청 메세지를 해석하고 행동을 취한다)_ : __`(3)`__
- 응답을 보낸다 _(응답을 클라이언트에게 돌려준다)_ : __`(6)`__

</div>
</details>
<br>

### 5.4　  단계 1: 클라이언트 커넥션 수락　 `mihykim`
- 특정 커넥션의 경우, 웹서버가 반드시 커넥션을 받아들여야 하기도 한다. __( O / X )__
- 새 커넥션이 맺어지고 받아들여지면 웹 서버는 새 커넥션을 커넥션 목록에 추가하고 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 한다 __( O / X )__
- 웹 서버는 역방향 DNS 또는 ident 프로토콜을 통해 사용자를 알아낼 수 있는데, 두 방법 모두 HTTP 트랜잭션 지연과는 관련이 없다. __( O / X )__
- 어떤 사용자이름이 HTTP 커넥션을 초기화했는지 서버가 알 수 있게 해주는 IETF ident 프로토콜은, 클라이언트 사용자이름의 노출로 인한 프라이버시 침해 우려가 있다. __( O / X )__

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 특정 커넥션의 경우, 웹서버가 반드시 커넥션을 받아들여야 하기도 한다.  __( X )__  __p131__
  - 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다.
  - 어떤 웹 서버들은 클라이언트의 IP주소나 호스트 명이 인가되지 않았거나 악의적이라고 알려진 것인 경우 커넥션을 닫는다.
- 새 커넥션이 맺어지고 받아들여지면 웹 서버는 새 커넥션을 커넥션 목록에 추가하고 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 한다 __( O )__  __p131__
- 웹 서버는 역방향 DNS 또는 ident 프로토콜을 통해 사용자를 알아낼 수 있는데, 두 방법 모두 HTTP 트랜잭션 지연과는 관련이 없다. __( X )__  __p132, p133__
  - 호스트명 룩업은 꽤 시간이 많이 걸릴 수 있어 웹 트랜잭션을 느려지게 할 수 있음을 미리 경고해두겠다.
  - ident 프로토콜은 HTTP 트랜잭션을 유의미하게 지연시킨다.
- 어떤 사용자이름이 HTTP 커넥션을 초기화했는지 서버가 알 수 있게 해주는 IETF ident 프로토콜은, 클라이언트 사용자이름의 노출로 인한 프라이버시 침해 우려가 있다. __( O )__  __p133__
  - [IETF](https://ko.wikipedia.org/wiki/%EA%B5%AD%EC%A0%9C_%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%91%9C%EC%A4%80%ED%99%94_%EA%B8%B0%EA%B5%AC)(국제 인터넷 표준화 기구, Internet Engineering Task Force)
  - [ident 프로토콜](https://en.wikipedia.org/wiki/Ident_protocol)
      - 특정 TCP 커넥션의 사용자를 식별하는 데 도움이되는 인터넷 프로토콜.

</div>
</details>
<br>

### 5.5　  단계 2: 요청 메시지 수신　 `mihykim`
- 웹 서버는 스페이스, CRLF 등으로 이미 파싱된 메세지 단위로 데이터를 받아서, 별도로 파싱 과정을 거치거나 일부를 버퍼에 저장해둘 필요는 없다. __( O / X )__
- 웹 클라이언트가 보낸 요청 메세지의 내용 중, 줄바꿈 또는 빈줄을 표현하기 위해 CRLF가 아닌 LF를 보낸다면 웹 서버는 줄바꿈을 제대로 인식하지 못할 것이다. __( O / X )__

<p align="center"><img src="https://user-images.githubusercontent.com/60066472/89037975-71fb8000-d37a-11ea-8571-05a2755f8ef1.jpg" width="600"></p>

- 위 그림을 참고하여 보기의 특성에 맞는 웹서버의 아키텍처를 기입해주세요 (a-d)
    - CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 멀티플렉싱을 결합한다 __(　　)__
    - 한 트랜잭션이 완료된 후에야 다음 커넥션을 처리할 수 있어 처리 도중에 모든 다른 커넥션은 무시된다 __(　　)__
    - 여러 커넥션을 동시에 처리할 수 있지만 그로 인해 만들어진 수많은 프로세스/스레드로 리소스 낭비가 과해질 수 있다 __(　　)__
    - 어떤 커넥션에 대해 작업을 수행하는 것은 그 커넥션에 실제로 할일이 있을 때 뿐이다 __(　　)__

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 웹 서버는 스페이스, CRLF 등으로 이미 파싱된 메세지 단위로 데이터를 받아서, 별도로 파싱 과정을 거치거나 일부를 버퍼에 저장해둘 필요는 없다. __( X )__ __p134__
  - 파싱이란?
    - 언어학에서 구문 분석 또는 '파싱'은 문장을 그것을 이루고 있는 구성 성분으로 분해하고 그들 사이의 위계 관계를 분석하여 문장의 구조를 결정하는 것을 말한다.
    - 컴퓨터 과학에서 파싱((syntactic) parsing)은 일련의 문자열을 의미있는 토큰(token)으로 분해하고 이들로 이루어진 파스 트리(parse tree)를 만드는 과정을 말한다.
  - 웹 서버는 입력 데이터를 네트워크로부터 불규칙적으로 받는다. 
  - 웹 서버는 파싱해서 이해하는 것이 가능한 수준의 분량을 확보할 때까지 데이터를 네트워크로부터 읽어서 메세지 일부분을 메모리에 임시로 저장해둘 필요가 있다.
- 웹 클라이언트가 보낸 요청 메세지의 내용 중, 줄바꿈 또는 빈줄을 표현하기 위해 CRLF가 아닌 LF를 보낸다면 웹 서버는 줄바꿈을 제대로 인식하지 못할 것이다. __( X )__  __p134__
  - 많은 웹 서버들이 LF와 CRLF 모두를 줄바꿈 문자로 인식한다. 줄의 끝을 표현하기 위해 실수로 LF를 보내는 클라이언트들도 종종 있기 때문이다.

<p align="center"><img src="https://user-images.githubusercontent.com/60066472/89037975-71fb8000-d37a-11ea-8571-05a2755f8ef1.jpg" width="600"></p>

- 위 그림을 참고하여 보기의 특성에 맞는 웹서버의 아키텍처를 기입해주세요 (a-d)
    - CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 멀티플렉싱을 결합한다 __(d)__
    - 한 트랜잭션이 완료된 후에야 다음 커넥션을 처리할 수 있어 처리 도중에 모든 다른 커넥션은 무시된다 __( a )__
    - 여러 커넥션을 동시에 처리할 수 있지만 그로 인해 만들어진 수많은 프로세스/스레드로 리소스 낭비가 과해질 수 있다 __(b)__
    - 어떤 커넥션에 대해 작업을 수행하는 것은 그 커넥션에 실제로 할일이 있을 때 뿐이다 __(c,d)__

</div>
</details>
<br>

### 5.6　  단계 3: 요청 처리　 `daelee`
1. 웹 서버가 요청을 받으면, 서버는 요청으로부터 `_____`, `_____`, `_____`, `_____`, 을 얻어내어 처리한다.
2. POST 메서드는 요청 메세지에 엔터티 본문이 있는 것을 허용하되 요구하지는 않는다. (O/X)
3. GET 메서드는 요청 메세지에 엔터티 본문이 있는 것을 허용하지 않는다. (O/X)
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 웹 서버가 요청을 받으면, 서버는 요청으로부터 `_____`, `_____`, `_____`, `_____`, 을 얻어내어 처리한다.

   > 메서드, 리소스, 헤더, 본문(없는 경우도 있음)

2. POST 메서드는 요청 메세지에 엔터티 본문이 있는 것을 허용하되 요구하지는 않는다. (X)

3. GET 메서드는 요청 메세지에 엔터티 본문이 있는 것을 허용하지 않는다. (O)

</div>
</details>
<br>

### 5.7　  단계 4: 리소스의 매핑과 접근　 `daelee`
1. 웹서버는 다른말로 리소스 서버다. 그들은 HTML 페이지나 JPEG 이미지 같은 미리 만들어진 **`__(a)__` 콘텐츠**를 제공하며, 마찬가지로 서버 위에서 동작하는 리소스 생성 애플리케이션을 통해 만들어진 **`__(b)__` 콘텐츠**도 제공한다.

2. 일반적으로 웹 서버 파일 시스템의 특별한 한 폴더를 웹 콘텐츠를 위해 사용한다. 이 폴더를 `_______`라고 부른다. 

3. 하나의 웹 서버 위에서 두 개(혹은 여러 개)의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅 되도록 하는 방법은?

   (매우 자유로운 서술형)

4. 웹 서버가 (파일이 아닌 디렉토리를 가리키는) 디렉토리 url에 대한 요청을 받았을 때 취하는 가장 일반적인 행동은?

   (매우 자유로운 서술형2)

5. 아래 그림에서 보여지는 서버를 흔히 `_______` 서버라고 부른다. 

   <img width="544" alt="image" src="https://user-images.githubusercontent.com/37580034/89208843-1e966580-d5f8-11ea-9fd6-53665a602b06.png">

6. 만약 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 그 리소스의 콘텐츠를 클라이언트에게 보낸 후 처리한다. (O/X)
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 웹서버는 다른말로 리소스 서버다. 그들은 HTML 페이지나 JPEG 이미지 같은 미리 만들어진 **정적 콘텐츠**를 제공하며, 마찬가지로 서버 위에서 동작하는 리소스 생성 애플리케이션을 통해 만들어진 **동적 콘텐츠**도 제공한다.

2. 일반적으로 웹 서버 파일 시스템의 특별한 한 폴더를 웹 콘텐츠를 위해 사용한다. 이 폴더를 `문서루트` 혹은 `docroot`라고 부른다. 

   > 리소스 매핑의 가장 단순한 형태는 요청 URI를 `dotroot` 안에 있는 파일의 이름으로 사용하는 것이다.

3. 하나의 웹 서버 위에서 두 개(혹은 여러 개)의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅 되도록 하는 방법은?

   > 웹서버를 가상 호스팅한다. 다른 말로, 각 사이트마다 분리된 `docroot`를 준다. 서버는 여러 웹사이트의 `docroot`를 HTTP Host헤더나 서로 다른 IP주소를 이용해 구분한다.  

4. 웹 서버가 (파일이 아닌 디렉토리를 가리키는) 디렉토리 url에 대한 요청을 받았을 때 취하는 가장 일반적인 행동은?

   > 대부분의 웹 서버는 요청한 url에 대응되는 디렉토리 안에서 `index.html` 혹은 `index.htm`으로 이름 붙은 파일을 찾아 그 파일의 콘텐츠를 반환한다.

   > 기본 색인 파일이 없거나 디렉토리 색인 기능이 꺼져 있지 않다면, 많은 웹 서버는 자동으로 그 디렉토리의 파일들을 `크기`, `변경일`, `해당 파일에 대한 링크`와 함께 열거한 HTML 파일을 반환한다.

   > **`.htm`이란?** html파일과 완전히 똑같음. 과거 MS-dos 시절 파일의 확장자를 3글자로 제한하던 관습이 남아있는 것.

5. 웹 서버가 동적 리소스를 제공할 때는, 그 동적 리소스를 생성할 수 있는 백엔드 애플리케이션(프로그램)에 URI를 매핑한다. 이런 작업을 하는 서버를 **애플리케이션 서버**라고 부른다. 

   ![image-20200803194714437](/Users/daelee/Library/Application Support/typora-user-images/image-20200803194714437.png)

6. 만약 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 그 리소스의 콘텐츠를 클라이언트에게 보낸 후 처리한다 (O/X)

   > html 문서를 parsing 해서 특정 위치에 값을 대입하는 과정.
   >
   > SSI 문장들을 포함하고 있는 웹파일은 대게 관리자에 의해 **.shtml** 이라는 확장자가 붙여 정의된다.
   >
   > 보통 사용자의 요청을 환경변수로 저장하고 있다가, **shtml 파일에서 SSI 명령을 만나면 그 안에 어떤 내용을 채우는 형식**이 된다.
   >
   > 동적 페이지를 만들기 쉽다는 장점이 있지만, 파싱이 필요하기 때문에 서버의 성능을 저하시킬수도 있다.

</div>
</details>
<br>

### 5.8　  단계 5: 응답 만들기　 `secho`

##### 1번. 보기에 따라 고르시오. 

(응답 메소드, 응답 메시지, 요청 메소드, 요청 메시지)

- 서버가 리소스를 식별하면 서버는 (..... _)로 서술되는 동작을 수행한 뒤 (_ .....)를 반환한다.


##### 2번.  보기에 따라 고르시오.

(Content-Length, Content-Type, 리소스, MIME, 객체)

- 트랜잭션이 응답 본문을 생성한다면, 그 내용을 응답 메시지와 함께 돌려보낸다. 응답 메시지는 다음을 포함한다.
  - 응답 본문의 (.....)타입을 서술하는 (.....)헤더
  - 응답 본문의 길이를 서술하는 (.....)헤더
  - 실제 응답 본문의 내용


##### 3번. 

- 웹 서버는 각 파일의 MIME타입을 알아낼 수 없다. ( O / X )
- 특정 파일이 특정 MIME타입을 갖게 웹서버를 설정할 수 없다.( O / X)


##### 4번. 다음 상황에 사용되는 응답은?

- 새 URL이 부여되어 이름이 바뀌거나 새로운 위치로 리소스가 옮겨졌을 때
- 리소스가 임시로 옮겨졌을 때
- 상태 정보를 포함한 뚱뚱한 URL을 생성하여 처리할 때
- 과부하된 서버가 요청을 받을 때
- 클라이언트에 대한 정보를 가진 다른 서버가 있을 때.
- 클라이언트가 URL요청을 할 때 빗금(/)을 빠트렸을 때.


##### 5번. 세초는 영구히 리소스가 옮겨진 `/main`경로로 `redirection`되었다. 세초가 서버로부터 받은 HTTP 응답 메시지는?

```
...
Status Code: (1.빈칸) Moved Permanently
Request Headers
Location: (2.빈칸)
```



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


##### 1번. 보기에 따라 고르시오. 

(응답 메소드, 응답 메시지, 요청 메소드, 요청 메시지)

- 서버가 리소스를 식별하면 서버는 (**요청메소드**)로 서술되는 동작을 수행한 뒤 (**응답 메시지**)를 반환한다.


##### 2번.  보기에 따라 고르시오.

(Content-Length, Content-Type, 리소스, MIME, 객체)

- 트랜잭션이 응답 본문을 생성한다면, 그 내용을 응답 메시지와 함께 돌려보낸다. 응답 메시지는 다음을 포함한다.
  - 응답 본문의 (**MIME**)타입을 서술하는 (**Content-Type**)헤더
  - 응답 본문의 길이를 서술하는 (**Content_Length**)헤더
  - 실제 응답 본문의 내용


##### 3번. 

- 웹 서버는 각 파일의 MIME타입을 알아낼 수 없다. ( O / **X** )
  - 웹 서버는 파일 내용을 검사해, 알려진 패턴에 대한 매직파일에 해당하는 패턴이 있는지 찾아서 MIME 타입을 알아낼 수 있다.
- 특정 파일이 특정 MIME타입을 갖게 웹서버를 설정할 수 없다.( **O** / X)
  - 파일 확장자나 내용에 상관없이 어떤 MIME타입을 갖도록 웹서버를 설정할 수 있다.


##### 4번. 다음 상황에 사용되는 응답은?

- 새 URL이 부여되어 이름이 바뀌거나 새로운 위치로 리소스가 옮겨졌을 때
- 리소스가 임시로 옮겨졌을 때
- 상태 정보를 포함한 뚱뚱한 URL을 생성하여 처리할 때
- 과부하된 서버가 요청을 받을 때
- 클라이언트에 대한 정보를 가진 다른 서버가 있을 때.
- 클라이언트가 URL요청을 할 때 빗금(/)을 빠트렸을 때.

**리다이렉트**


=> 뚱뚱한 URL? 웹사이트를 처음 방문시 유효한 ID를 생성해주는데 서버가 그 값을 인식할 수 있는 방법으로 URL을 추가한다. 이를 뚱뚱한 URL이라하고,
서버는 클라이언트를 뚱뚱한 URL로 리다이렉트시킨다. => 아마존이 이렇게 사용함. =>~~이제 안쓴다고하는데 아마존은 왜쓰지?~~


##### 5번. 세초는 영구히 리소스가 옮겨진 `/main`경로로 `redirection`되었다. 세초가 서버로부터 받은 HTTP 응답 메시지는?

```
...
Status Code: 301 Moved Permanently
Request Headers
Location: /main
```



</div>
</details>
<br>

### 5.9　  단계 6: 응답 보내기　 `secho`


##### 6번

- 서버는 여러 클라이언트에 많은 커넥션을 가질 수 있다 ( O / X )
- 지속 커넥션인 경우 서버는 Content-Length 헤더를 바르게 계산하기 위해 커넥션을 유지한다. ( O / X )
- 비지속 커넥션인 경우 서버가 모든 메시지를 전송했을 때 서버의 커넥션을 닫는다. ( O / X )

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">

- 서버는 여러 클라이언트에 많은 커넥션을 가질 수 있다 ( **O** / X )
- 지속 커넥션인 경우 서버는 Content-Length 헤더를 바르게 계산하기 위해 커넥션을 유지한다. ( **O** / X )
- 비지속 커넥션인 경우 서버가 모든 메시지를 전송했을 때 서버의 커넥션을 닫는다. ( **O** / X )

</div>
</details>
<br>

### 5.10　  단계 7: 로깅　 `secho`

##### 7번
- 트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지 로그를 로그파일에 기록하지 않는다 (O / X)
- [nodeJS 로그파일 생성하는 법](https://velog.io/@pizzu/nodejs-%EB%A1%9C%EA%B7%B8%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1-%ED%95%98%EB%8A%94-%EB%B2%95)

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


- 트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지 로그를 로그파일에 기록하지 않는다 (O / **X**)

  - 기록함!

</div>
</details>
<br>

[맨위로](#05장-octopus-웹-서버)

