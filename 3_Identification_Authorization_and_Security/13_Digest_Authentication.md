## 13장 :octopus: 다이제스트 인증

### __13.1__ 　 다이제스트 인증의 개선점　 `taelee`

##### 1. 다이제스트 인증은 기본 인증을 대체하기 위해 설계되어 기본 인증보다 훨씬 강력하다(O/X)

##### 2. 다이제스트 인증은 다른 인터넷 서비스를 위해 제안된 많은 인기 이는 보안 체계들(LDAP, POP, IMAP)보다 더 강력한 보안을 제공하기 때문에 현재 널리 쓰인다(O/X)

##### 3. 다이제스트는 절대로 네트워크를 통해 비밀번호를 평문으로 전송하지 않는다(O/X)

##### 4. 보안히 강력한 다이제스트 인증도 허점이 있다. 악당이 비밀번호를 모른다고 해도 `____`을 가로채서 서버로 몇 번이고 재전송해서 인증을 무력화 할 수 있기 때문이다. 이런 재전송 공격을 방지하기 위해서 서버는 클라이언트에게 `____`라고 불리는 특별한, 그리고 자주 바뀌는 증표를 건네준다.



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
##### 1. 다이제스트 인증은 기본 인증을 대체하기 위해 설계되어 기본 인증보다 훨씬 강력하다(O)


##### 2. 다이제스트 인증은 다른 인터넷 서비스를 위해 제안된 많은 인기 이는 보안 체계들(LDAP, POP, IMAP)보다 더 강력한 보안을 제공하기 때문에 현재 널리 쓰인다(X)

현재 널리 쓰이지 않고 있다. 주로 SSL을 이용한 HTTPS가 많이 쓰인다.

##### 3. 다이제스트는 절대로 네트워크를 통해 비밀번호를 평문으로 전송하지 않는다(O)

다이제스트 인증은 사용자의 비밀번호를 단방향 암호화해서 "요약"의 형태로 서버에게 보내준다.

##### 4. 보안히 강력한 다이제스트 인증도 허점이 있다. 악당이 비밀번호를 모른다고 해도 `요약(다이제스트)`을 가로채서 서버로 몇 번이고 재전송해서 인증을 무력화 할 수 있기 때문이다. 이런 재전송 공격을 방지하기 위해서 서버는 클라이언트에게 `난스`라고 불리는 특별한, 그리고 자주 바뀌는 증표를 건네준다.

</div>

</div>
</details>
<br>

### __13.2__ 　 요약 계산　 `yeosong`

`다이제스트 인증`은 현재 그다지.. 사용되고 있지 않지만!

`난스`와 `단방향 함수`로 `다이제스트(요약)`하여 보안 정도를 높이는

`다이제스트 인증`의 계산법에 대해 알아보자! 

  

### __13.2.1__ 　 요약 알고리즘 입력 데이터

**1)** 다음은 다이제스트 알고리즘의 구성요소들이다. 각 요소에 맞는 설명을 골라 적으세요. 

  `secret` `단방향 해시 함수` `요약 함수` `data`

  `비밀인 data 덩어리`

  `비밀이 아닌 data 덩어리` 

  

  - H(d)        ---------------- `________` ( `____`)

  - KD(s, d)  ------------- `_____` ( `______`,  `____`)

  - A1           ---------------- `______________`

  - A2           ---------------- `______________` 

  

### __13.2.2__ 　 H(d)와 KD(s,d) 알고리즘

  **2)** 다이제스트 인증은 여러가지 요약 알고리즘을 선택할 수 있도록 지원하지만, 정해지지 않았을 경우 `MD5`가 기본 값이다. (O ------ X)

  

### __13.2.3__ 　 보안 관련 데이터(A1)

  다이제스트 알고리즘의 구성 요소중 하나인 **A1**은 아래 요소들과 같이 배치해 해시를 만든다.

  ~~~
  MD5				A1 = <user>:<realm>:<password>
  MD5=sess	A1 = MD5(<user>:<realm>:<password>):<nonce>:<cnonce>
  ~~~

  

### __13.2.4__ 　 메시지 관련 데이터(A2)

  **3)** `qop`가 무엇인가요? (단답식)

  

  RFC2617(는 obsoletes이고 현재 [RFC7616](https://www.rfc-editor.org/rfc/rfc7616.txt)) 은 qop에 따라 2가지 형태의 **A2**를 사용하도록 정의하고 있다.

  1. 기본값 

     ~~~
     qop 옵션이 없을 경우, 또는
     qop = "auth" 일 경우          A2 = <요청 메서드>:<uri 지시자 값> 
     ~~~

      

  2. 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가

     ~~~
     qop = "auth-int" 일 경우      A2 = <요청 메서드>:<uri 지시자 값>:H(<요청 엔터티 본문>)
                                                               ~~~~~~~~~~~~~~~~~
     ~~~

  

### __13.2.5__ 　 요약 알고리즘 전반

  다이제스트를 계산하는 2가지 방법

  ~~~
  qop 옵션이 없을 경우               MD5(MD5(A1):<난스>:MD5(A2))
  
  qop = "auth" , 또는
  qop = "auth-int" 일 경우         MD5(MD5(A1):<난스>:<c난스>:<qop>:MD5(A2))
                                                   ~~~~~~~~~~~~
  ~~~

  

### __13.2.6__ 　 다이제스트 인증 세션

  인증 세션에서 난스가 만료 되었을 경우,

  - 서버는 난스가 낡았음을 감수하고 오래된 `Authorization 헤더`를 받아들일 수 있다.
  - 서버는 클라이언트가 재요청을 보내도록 새 난스 값과 `401`응답을 보낼 수도 있다.
    - 이 때 `"stale=true"`로 정의하여 (== `"싱싱하지 않은가=그렇다"`) 새 난스 값으로 요청을 다시 보내라고 할 수 있다.

  

### __13.2.7__ 　 사전(preemptive) 인가

  더 효율적이고 빠른 트랜잭션을 위해 사전(preemptive 발음: prēˈemptiv) 인가를 사용 할 수 있다.

  사전 인가는 클라이언트가 서버로부터 `WWW-Authenticate` 인증 요구를 기다리지 않고 미리 올바른 난스를 취득하여 계산하도록 하는 것이다

 #### 4) [다음 난스 미리 생성하기]는 인증이 성공했을 때, 서버에서 `200 OK`와 함께 `Authentication-Info: nextnonce="<난스값>"` 을 보내는 방식이다. 이 방법은 어떤 상황일 때 단점이 될까? (주관식)

 #### 5) [제한된 난스 재사용]은 어떤 단점이 있을까? (주관식)

 #### 6) 사전 인가를 위해 [동기화된 난스 생성]을 할 수도 있다. 어떤 식으로 가능한가? (주관식)

  

### __13.2.8__ 　 난스 선택

  난스는 어떻게 구현하는가에 따라 성능 수준, 보안, 편의성이 크게 달라진다.

  [RFC7616](https://www.rfc-editor.org/rfc/rfc7616.txt)은 다음과 같은 가상의 난스 공식을 제안한다.

  BASE64(time-stamp H(time-stamp ":" ETag ":" secret-data))

  

  - 타임스탬프는 서버에서 생성된 시간 혹은 아무거나 `반복 불가능한 값`이면 된다. -----> 보안
  - ETag는 요청된 엔터티에 대한 `ETag 헤더값` -----> 갱신된 리소스에 대한 재요청 방지
  - 비밀 데이터는 `서버만 알고 있는 데이터` -----> 보안

  

  - 서버는 클라 인증 헤더를 받은 뒤,

    - 해시를 재계산 해보고 클라 인증 헤더의 난스와 일치하지 않으면 요청 거절 가능
    - 타임스탬프가 오래되었다면 요청 거절 가능

    - 난스의 유효 기간을 제한 가능
    - 재전송 공격 방지를 위해 이전에 사용된 난스 및 요약을 받아들이지 않도록 제한 가능

    

### __13.2.9__ 　 상호 인증

  **7)** 다음은 **상호 인증(Symmetric Authentication)**에 대한 설명으로 **틀린 것은**? 

  1. 클라이언트 쪽에서도 서버를 인증할 수 있도록 `클라이언트` 가 `난스(=c난스)`를 제공하고, 서버는 이 요약을 `Authentication-Info 헤더`를 통해 클라이언트에 전달하여 인증 받는 것이다.

  2. `응답 다이제스트`는 메시지 본문 정보가 다르다는 것만 제외하면 `요청 다이제스트`와 같은 방법으로 계산할 수 있다.

  

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">


### __13.2.1__ 　 요약 알고리즘 입력 데이터

**1)** 다음은 다이제스트 알고리즘의 구성요소들이다. 각 요소에 맞는 설명을 골라 적으세요. 

`secret` `단방향 해시 함수` `요약 함수` `data`

`비밀인 data 덩어리`

`비밀이 아닌 data 덩어리` 



- H(d)        ---------------- `단방향 해시 함수` ( `data`)

- KD(s, d)  ------------- `요약 함수` ( `secret`,  `data`)

- A1           ---------------- `비밀인 data 덩어리`

- A2           ---------------- `비밀이 아닌 data 덩어리` 



### __13.2.2__ 　 H(d)와 KD(s,d) 알고리즘

**2)** 다이제스트 인증은 여러가지 요약 알고리즘을 선택할 수 있도록 지원하지만, 정해지지 않았을 경우 `MD5`가 기본 값이다. **(O)**



#### 참고 - MD5? 옛날 얘기

- `Message Digest #5`의 약어

-  `SHA(시큐어 해시 알고리즘)` 같은 다이제스트 함수 중 하나
-  128비트 암호화 해시 함수

- [**취약점이 발견되었고**](https://ko.wikipedia.org/wiki/MD5) 노트북 하나로 1분내로 해시 충돌을 찾는 알고리즘이 나올정도로 취약해졌다.  **= 이제 안쓴다 (쓰면 안된다)**
  - `SHA-0`, `SHA-1`도 마찬가지로 보안 뚫린 상태. `SHA-256`, `SHA-512` 등을 사용하기를 권고한다고 합니다.



### __13.2.3__ 　 보안 관련 데이터(A1)

다이제스트 알고리즘의 구성 요소중 하나인 **A1**은 아래 요소들과 같이 배치해 해시를 만든다.

~~~
MD5				A1 = <user>:<realm>:<password>
MD5=sess	A1 = MD5(<user>:<realm>:<password>):<nonce>:<cnonce>
~~~



### __13.2.4__ 　 메시지 관련 데이터(A2)

**3)** `qop`가 무엇인가요? (단답식)

- quality of protection. 보호 수준.



RFC2617(는 obsoletes이고 현재 [RFC7616](https://www.rfc-editor.org/rfc/rfc7616.txt)) 은 qop에 따라 2가지 형태의 **A2**를 사용하도록 정의하고 있다.

1. 기본값 

   ~~~
   qop 옵션이 없을 경우, 또는
   qop = "auth" 일 경우          A2 = <요청 메서드>:<uri 지시자 값> 
   ~~~

    

2. 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가

   ~~~
   qop = "auth-int" 일 경우      A2 = <요청 메서드>:<uri 지시자 값>:H(<요청 엔터티 본문>)
                                                             ~~~~~~~~~~~~~~~~~
   ~~~



### __13.2.5__ 　 요약 알고리즘 전반

다이제스트를 계산하는 2가지 방법

~~~
qop 옵션이 없을 경우               MD5(MD5(A1):<난스>:MD5(A2))

qop = "auth" , 또는
qop = "auth-int" 일 경우         MD5(MD5(A1):<난스>:<c난스>:<qop>:MD5(A2))
                                                 ~~~~~~~~~~~~
~~~



### __13.2.6__ 　 다이제스트 인증 세션

인증 세션에서 난스가 만료 되었을 경우,

- 서버는 난스가 낡았음을 감수하고 오래된 `Authorization 헤더`를 받아들일 수 있다
- 서버는 클라이언트가 재요청을 보내도록 새 난스 값과 `401`응답을 보낼 수도 있다.
  - 이 때 `"stale=true"`로 정의하여 새 난스 값으로 요청을 다시 보내라고 할 수도 있다.



### __13.2.7__ 　 사전(preemptive) 인가

더 효율적이고 빠른 트랜잭션을 위해 사전(preemptive 발음: prēˈemptiv) 인가를 사용 할 수 있다.

사전 인가는 클라이언트가 서버로부터 `WWW-Authenticate` 인증 요구를 기다리지 않고 미리 올바른 난스를 취득하여 계산하도록 하는 것이다

#### 4) [다음 난스 미리 생성하기]는 인증이 성공했을 때, 서버에서 `200 OK`와 함께 `Authentication-Info: nextnonce="<난스값>"` 을 보내는 방식이다. 이 방법은 어떤 상황일 때 단점이 될까? (주관식)

- **같은** 서버에 **다중 요청**을 하는 경우에는 다음 요청을 보내기 전에 다음 난스값을 받아야만 하는 특징 때문에 오히려 성능이 낮아지게 된다. 343p
  - 이런 경우에는 난스 재사용이 더 나을 것 같다. 위의 경우, 오지 않는 다음 난스를 기다리거나 / 같은 난스를 또 받는 비효율적인 수행을 반복하거나.. 그런 거겠죠? 이 부분 제가 맞게 이해한걸까요? 



#### 5) [제한된 난스 재사용]은 어떤 단점이 있을까? (주관식)

- [앞에서 본 긴 커넥션의 보안 이슈](https://github.com/Kraken-Addicts/HTTP-The-Definitive-Guide/blob/master/2_HTTP_Architecture/10_HTTP.md#104---알려진-보안-이슈-kukim)와 마찬가지로, `연결 시간이 길어질수록 공격의 성공률은 높아진다.` 여기서 공격은 재전송 공격(Replay Attack)을 말한다.
  - `카운터 증가`(송신 메시지에 매회 1씩 증가하는 번호를 함께 전달), `IP 주소 검사` 등으로 재전송 공격을 어렵게 만들 수는 있지만 근본적인 취약점을 제거하는 해결법은 아니다.


#### 6) 사전 인가를 위해 [동기화된 난스 생성]을 할 수도 있다. 어떤 식으로 가능한가? (주관식)

- `시간적으로 동기화` 된 알고리즘을 쓴다: 공유된 `비밀키`를 기반으로 클라와 서버가 같은 난스를 순차적으로 생성한다.
  - 이는 `다이제스트 인증` 명세의 범위를 넘어서는 것이다.



### __13.2.8__ 　 난스 선택

- 난스는 어떻게 구현하는가에 따라 성능 수준, 보안, 편의성이 크게 달라진다.

  [RFC7616](https://www.rfc-editor.org/rfc/rfc7616.txt)은 다음과 같은 가상의 난스 공식을 제안한다.

  BASE64(time-stamp H(time-stamp ":" ETag ":" secret-data))

  

  - 타임스탬프는 서버에서 생성된 시간 혹은 아무거나 `반복 불가능한 값`이면 된다. -----> 보안
  - ETag는 요청된 엔터티에 대한 `ETag 헤더값` -----> 갱신된 리소스에 대한 재요청 방지
  - 비밀 데이터는 `서버만 알고 있는 데이터` -----> 보안

  

  - 서버는 클라 인증 헤더를 받은 뒤,

    - 해시를 재계산 해보고 클라 인증 헤더의 난스와 일치하지 않으면 요청 거절 가능
    - 타임스탬프가 오래되었다면 요청 거절 가능

    - 난스의 유효 기간을 제한 가능
    - 재전송 공격 방지를 위해 이전에 사용된 난스 및 요약을 받아들이지 않도록 제한 가능



### __13.2.9__ 　 상호 인증

**7)** 다음은 **상호 인증(Symmetric Authentication)**에 대한 설명으로 **틀린 것은**?  없다.

1. 클라이언트 쪽에서도 서버를 인증할 수 있도록 `클라이언트` 가 `난스(=c난스)`를 제공하고, 서버는 이 요약을 `Authentication-Info 헤더`를 통해 클라이언트에 전달하여 인증 받는 것이다.

2. `응답 다이제스트`는 메시지 본문 정보가 다르다는 것만 제외하면 `요청 다이제스트`와 같은 방법으로 계산할 수 있다.

  

</div>
</details>
<br>

### __13.3__ 　 보호 수준(Quality of Protection) 향상　 `secho`



1번.

다음 빈칸에 해당하는 것을 보기를 보고 모두 고르세요.

보기 :  `Cache-control, WWW-Authenticate, auth, auth-int, MD5, MD5-sess, Authorization, Authentication-Info`

클라이언트, 서버가 어떤 보호기법을 

어느 수준 까지 사용할 것인지를 협상할 수 있게 해주는

qop필드는 요약헤더의에 `___`,`___`,`___`에 존재할 수 있다.

<br>

2번.

다음의 빈칸을 채우세요.

`RFC 2617`은 기본적으로 인증을 의미하는 `____`, 인증 및 메세지 무결성 보호를 의미하는 `____`라는 초기 보호수준 값을 정의하고 있다.

<br>



<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">



1번.

다음 빈칸에 해당하는 것을 보기를 보고 모두 고르세요.

보기 :  `Cache-control, WWW-Authenticate, auth, auth-int, MD5, MD5-sess, Authorization, Authentication-Info`

클라이언트, 서버가 어떤 보호기법을 

어느 수준 까지 사용할 것인지를 협상할 수 있게 해주는

qop필드는 요약헤더의에 `___`,`___`,`___`에 존재할 수 있다.

<br>



정답 : `WWW-Authenticate, Authorization, Authentication-Info`



<br>



2번.

다음의 빈칸을 채우세요.

`RFC 2617`은 기본적으로 인증을 의미하는 `____`, 인증 및 메세지 무결성 보호를 의미하는 `____`라는 초기 보호수준 값을 정의하고 있다.

정답 : `auth`, `auth-int`

</div>
</details>
<br>

### __13.4__ 　 실제 상황에 대한 고려　 `secho`

3번.

서버는 한 리소스에 대해 하나의 인증을 요구할 수밖에 없고 , 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야한다. ( O / X)

<br>



4번.

프락시는 가리키는 리소스의 변경없이 구문만 고쳐서 URI를 변경할 수 있다. 다이제스트인증은 이러한 변경에 의해 실패할 수 있다 ( O / X)

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">



3번.

서버는 한 리소스에 대해 하나의 인증을 요구할 수밖에 없고, 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야한다. ( O / X)

정답 : `X` `서버는 한 리소스에 대해 여러 인증을 요구할 수 있다.`



<br>



4번.

프락시는 가리키는 리소스의 변경없이 구문만 고쳐서 URI를 변경할 수 있다. 다이제스트인증은 이러한 변경에 의해 실패할 수 있다 ( O / X)



정답 : `O ,  다이제스트 인증은 URI값의 무결성을 검사하므로, 변경에 의해 실패할 수 있음. -> A2의 요청 URI와 일치해야한다는 특성 (340p)`



</div>
</details>
<br>

### __13.5__ 　 보안에 대한 고려사항　 `kukim`
1. 보호 수준에 대한 정보는 `(__________________)`와 `(_________)`헤더에만 담겨있다.
2. 재전송 공격은 무엇인가요? 다음 괄호를 채우세요.
- 재전송 공격이란 공격자가 공격할 대상의 인증정보가 담긴 `(____)`을 재활용하는 것이다. 서버가 재전송된 자격을 승인했다는 것은 같은 `(__)` 값을 반복해서 사용한 것이다. 이 문제를 피할 수 있는 방법은 `(_____________________________________)` 이다.
3. 다이제스트 인증의 장점과 그 한계는 무엇인가요? 다음 괄호를 채우세요.
- 다이제스트 인증이 `(____)`에 비해 안전한 해결책을 제공한다. 하지만 여전히 `(___)`에 대한 보안 측면에서는 어떠한 보호도 제공하지 못한다. 따라서 진정한 보안 트랜젝션은 오로지 다음 장에서 다룰 `(___)`을 통해서만 가능하다.
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 보호 수준에 대한 정보는 `(WWW-Authenticate)`와 `(Authorization)`헤더에만 담겨있다.
2. 재전송 공격은 무엇인가요? 다음 괄호를 채우세요.
- 재전송 공격이란 공격자가 공격할 대상의 인증정보가 담긴 `(트랜잭션)`을 재활용하는 것이다. 서버가 재전송된 자격을 승인했다는 것은 같은 `(난스)` 값을 반복해서 사용한 것이다. 이 문제를 피할 수 있는 방법은 `(매 트랜젝션 마다 유일한 난스 값을 사용하는 것)` 이다.
3. 다이제스트 인증의 장점과 그 한계는 무엇인가요? 다음 괄호를 채우세요.
- 다이제스트 인증이 `(기본 인증)`에 비해 안전한 해결책을 제공한다. 하지만 여전히 `(콘텐츠)`에 대한 보안 측면에서는 어떠한 보호도 제공하지 못한다. 따라서 진정한 보안 트랜젝션은 오로지 다음 장에서 다룰 `(SSL)`을 통해서만 가능하다.

</div>
</details>
<br>
