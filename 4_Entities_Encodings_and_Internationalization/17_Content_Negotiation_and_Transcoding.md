## 17장 :octopus: 내용 협상과 트랜스코딩
### __17.1__ 　  내용 협상 기법　 `kukim`
1. 내용 협상(content-negotiation)이란 무엇인가? `주관식`

2. 보기를 참고해 다음 괄호를 채우시오.

    ```bash
    <보기>
    1. 서버 입장에서 가장 구현하기 쉽다. 클라리언트는 최선의 선택을 할 수 있다.
    2. 서버가 클라이언트의 요청 헤더를 검증해서 어떤 버전을 제공할지 결정한다.
    3. 클라이언트 주도
    4. 클라이언트 핸드 쉐이크
    5. 투명
    6. 투명한 정도
    7. 웹 서버가 협상을 할 필요가 없다. 클라리언트 주도 협상보다 빠르다.
    8. 만약 결정이 뻔하지 않으면 (헤더에 맞는 거싱 없으면), 서버는 추측을 해야만 한다.
    ```
    <p align="center"><img src="https://user-images.githubusercontent.com/57086195/92450684-b0e0e900-f1f6-11ea-88aa-168809972003.png" width="700"></p>
  
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 내용 협상(content-negotiation)이란 무엇인가? `주관식`
  - 하나의 URL이 여러 가지 리소스 중 적합한 것에 대응되도록 할 수 있는 것 ( ex) 같은 웹페이지의 한국어, 영어, 터키어 버전을 제공)
  - 서버에 있는 페이지들 중 어떤 것이(어떤 버전이, 어떤 언어가 . . .) 클라이언트에게 맞는지 판단하는 방법

2. 보기를 참고해 다음 괄호를 채우시오.

    ```bash
    <보기>
    1. 서버 입장에서 가장 구현하기 쉽다. 클라리언트는 최선의 선택을 할 수 있다.
    2. 서버가 클라이언트의 요청 헤더를 검증해서 어떤 버전을 제공할지 결정한다.
    3. 클라이언트 주도
    4. 클라이언트 핸드 쉐이크
    5. 투명
    6. 투명한 정도
    7. 웹 서버가 협상을 할 필요가 없다. 클라리언트 주도 협상보다 빠르다.
    8. 만약 결정이 뻔하지 않으면 (헤더에 맞는 거싱 없으면), 서버는 추측을 해야만 한다.
    ```
    <p align="center"><img src="https://user-images.githubusercontent.com/57086195/92450684-b0e0e900-f1f6-11ea-88aa-168809972003.png" width="700"></p>
  - 정답 :  (a - 3), (b - 1), (c - 2), (d - 8), (e - 5), (f - 7)

</div>
</details>
<br>

### __17.2__ 　  클라이언트 주도 협상　 `kukim`
1. 다음 괄호를 채우시오.
- 서버가 클라이언트에게 데이터를 제공해줄 때 두 가지 방법이 있다. 1)여러 가지 버전에 대한 링크와 각각에 대한 설명이 담긴 HTML 페이지를 돌려주거나, 2) `( )` 응답 코드로 HTTP/1.1 응답을 돌려주는 것이다.

2. 클라이언트 주도 협상을 할 때 클라이언트는 각 페이지에 몇 번 요청이 필요한가?
    
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 다음 괄호를 채우시오.
- 서버가 클라이언트에게 데이터를 제공해줄 때 두 가지 방법이 있다. 1)여러 가지 버전에 대한 링크와 각각에 대한 설명이 담긴 HTML 페이지를 돌려주거나, 2) `( )` 응답 코드로 HTTP/1.1 응답을 돌려주는 것이다.
    - 300 Multiple Choices
2. 클라이언트 주도 협상을 할 때 클라이언트는 각 페이지에 몇 번 요청이 필요한가?
    - 두 번의 요청이 필요하다.
    - 한 번은 목록을 얻을 때 (내가 요청한 페이지가 어떤 언어로 이루어져 있는지 전체 확인)
    - 한 번은 내가 요청한 사본을 얻을 때 필요하다. (어떤 언어로 되어있는지 확인한 후 내가 확인할 수 있는 언어로 다시 요청)

</div>
</details>
<br>

### __17.3__ 　  서버 주도 협상　 `kukim`

1. 보기를 참고하여 다음 괄호를 채우세요.
    ```bash
    <보기>
    - 서버
    - 프락시
    - 캐시서버
    - 내용 협상 헤더
    - 이것이 네고여
    - 내용 협박 헤더 외의 다른 헤더
    - 내용 협상 헤더 외의 다른 헤더
    ```
    - 서버 주도 협상에는 `( )`  가 클라이언트에게 보내줄 적절한 응답을 계산하는 메커니즘은 두 가지가 있다.
        1. 하나는 `( )` 를 살펴본다. 서버는 클라이언트의 Accept 관련 헤더들을 들여다보고 그에 알맞은 응답 헤더를 준비한다.
        2. 다른 하나는 `( )` 를 살펴본다. 예를 들어, 서버는 클라이언트의 User-Agent 헤더에 기반하여 응답을 보내줄 수도 있다.

2. 클라이언트가 서버에게 아래와 같은 헤더를 통해 요청했다. 서버는 fr, kr, en 버전의 콘텐츠를 가지고 있다. 어떤 버전을 클라이언트에게 보내주겠는가?

    ```bash
    Accept-Language: nl;q=1.0, en;q=0.6, tr;q=0.58, kr;q=0.7, fr;q=0.9
    ```
    
3. 서버는 User-Agent와 같은 클라이언트의 다른 요청 헤더들을 이용해 알맞은 요청을 만들 수 있다. 예를 들어 User-Agent를 통해 클라이언트가 자바스크립트를 지원하지 않는 다는 것을 알고 있다면 응답 메세지에는 자바스크립트를 포함하지 않은 페이지를 돌려줄 수 있다. (O / X)
    
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
1. 보기를 참고하여 다음 괄호를 채우세요.
    ```bash
    <보기>
    - 서버
    - 프락시
    - 캐시서버
    - 내용 협상 헤더
    - 이것이 네고여
    - 내용 협박 헤더 외의 다른 헤더
    - 내용 협상 헤더 외의 다른 헤더
    ```    
    - 서버 주도 협상에는 `( )`  가 클라이언트에게 보내줄 적절한 응답을 계산하는 메커니즘은 두 가지가 있다.
        1. 하나는 `( )` 를 살펴본다. 서버는 클라이언트의 Accept 관련 헤더들을 들여다보고 그에 알맞은 응답 헤더를 준비한다.
        2. 다른 하나는 `( )` 를 살펴본다. 예를 들어, 서버는 클라이언트의 User-Agent 헤더에 기반하여 응답을 보내줄 수도 있다.
    - 정답 : `서버`, `내용 협상 헤더, `내용 협상 헤더 외의 다른 헤더`
2. 클라이언트가 서버에게 아래와 같은 헤더를 통해 요청했다. 서버는 fr, kr, en 버전의 콘텐츠를 가지고 있다. 어떤 버전을 클라이언트에게 보내주겠는가?

    ```bash
    Accept-Language: nl;q=1.0, en;q=0.6, tr;q=0.58, kr;q=0.7, fr;q=0.9
    ```
    - 정답 : 서버가 가지고 있는 버전과 클라이언트가 요청한 헤더 중 동일한 버전의 헤더 품질값이 가장 큰 fr 버전을 보내준다.
    
3. 서버는 User-Agent와 같은 클라이언트의 다른 요청 헤더들을 이용해 알맞은 요청을 만들 수 있다. 예를 들어 User-Agent를 통해 클라이언트가 자바스크립트를 지원하지 않는 다는 것을 알고 있다면 응답 메세지에는 자바스크립트를 포함하지 않은 페이지를 돌려줄 수 있다. (O / X)
    - 정답 : O
    
    
</div>
</details>
<br>

### __17.4__ 　  투명 협상 `junslee`
- 여기에
- 문제를 작성해주세요
<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
- 여기에
- 해설을 작성해주세요

</div>
</details>
<br>

### __17.5__ 　  트랜스코딩 `mihykim`
#### (학습목표) 트랜스코딩 vs 인코딩 구분하기
- 각 문제의 설명을 읽고, 보기에서 가장 연관이 깊은 항목을 골라주세요! (택1)
    | 보기 |
    |:---|
    | - 트랜스코딩(Transcoding) <br> - 전송 인코딩(Chunked Transfer Encoding) <br> - 콘텐츠 인코딩(Content-Encoding)|
    - __[문제1]__ 서버 태혁이는 효과적인 전송을 위해 메세지 본문(만)을 압축하였다.
        - 발신 메세지의 헤더 `Content-Encoding:gzip`
    - __[문제2]__ 마스터 도비는 1년 전 자신이 현재의 자신에게 보낸 HTTP 메세지를 받았다.
        - 인코딩된 메세지의 끝 `길이가 0인 종료청크`
        - 디코딩된 메세지 본문 `HTTP 스터디 다음 시간이 마지막인데, 그런 의미에서 협곡 가실 분?`
    - __[문제3]__ 아기 대현이는 20년 전, 아버지의 흑백 폰을 빌려, 데스크톱 클라이언트를 위해 만들어진 주니버 꾸러기에 접속하였다.
        - 모바일 단말기에 띄워진 화면 `WML 문서, 저해상도 이미지, 흑백 이미지, 단순한 텍스트 페이지`
<br>

#### (학습목표) 트랜스코딩 3종류 구분하기
- 각 문제의 설명을 읽고, 보기에서 가장 연관이 깊은 항목을 골라주세요! (택1)
    | 보기 |
    |:---|
    | - 포맷변환(format conversion) <br> - 정보합성(information synthesis) <br> - 콘텐츠주입(content injection) |
    - __[문제4]__ 잘나가는 현준이는 친구와 함께 홍대맛집을 검색하던 중, 몰래 들어갔던 웹사이트와 관련된 광고가 자동으로 생성되어 브라우저에 표시되어 몹시 당황하였다.
    - __[문제5]__ 영어신 정아는 미리 녹음해둔 42야우리두 스터디자료(녹음파일)가 사용하는 음악플레이어에서 열리지 않자, 파일을 mp4로 변환해서 문제를 해결하였다.
    - __[문제6]__ 웹개발 중 궁금한 점이 생긴 준서는 리액트 공식홈페이지에 들어갔는데, 각 절의 제목에 기반해 문서의 개요가 생성되어 있어 찾으려한 내용을 금방 찾을 수 있었다.
<br>
    
#### :cookie: 책에 나오는 WML이 뭔가요?
- __WML(Wireless Markup Language)__
    - XML에 기반을 둔 무선인터넷용 언어로써, 기존의 HTML을 개선한 무선 소형 단말을 위해 설계된 마크업 언어
    ![image](https://user-images.githubusercontent.com/60066472/92931438-6bcee800-f47e-11ea-8124-68ec198381d9.png)
<br>

- __XHTML(Extensible Hypertext Markup Language)__
    - XHTML은 HTML의 후속으로 많은 사람들이 XHTML을 HTML의 "최신 버전"으로 보고 있다. 하지만 HTML과 XHTML은 별개의 분리된 표준이다. [(더보기, 위키)](https://ko.wikipedia.org/wiki/XHTML)
        ![image](https://user-images.githubusercontent.com/60066472/92931538-902ac480-f47e-11ea-999d-e1f58123d69f.png)
<br>

<details>
<summary> <b> :page_facing_up: 답지 </b>  </summary>
<div markdown="1">
  
#### (학습목표) 트랜스코딩 vs 인코딩 구분하기
- 문제1 : 콘텐츠 인코딩(Content-Encoding)
- 문제2 : 전송 인코딩(Chunked Transfer Encoding)
- 문제3 : 트랜스코딩(Transcoding)
- 문제4 : 콘텐츠주입(content injection)
- 문제5 : 포맷변환(format conversion)
- 문제6 : 정보합성(information synthesis)
</div>
</details>
<br>
